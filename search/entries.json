[{"text":"Monads I know... yet another Monad tutorial. ğŸ™ƒ Have you ever thought \"hmm, these all look kinda same\": Promise, Future, Rx, IO, Monad await, flatMap, do, for then you might be right! Let's see! First we'll see how and why the Monad abstraction came into Haskell (a purely functional programming language). Then we will see a nicer syntax for writing functions that operate on monads. And lastly I will show you that await/for/do is \"just nicer syntax\" for flatMap. Haskell A few relevant things about Haskell: it is a lazy language it wants to separate pure functions from impure functions (actions) Laziness By \"lazy\" we mean evaluation is not strict. In Java for example, when you call a function myFun(a, b), the order of evaluation is strict and consistent: first, the arguments are evaluated: left to right, one by one function is evaluated But in Haskell that's not the case. Nothing is evaluated until needed. So if the parameter a is not used in the body of myFun it will not be evaluated at all. This is fine+desirable+performant when your functions are pure (not doing anything), but it is a big issue when they do side effects: write to a file/db etc. For example, if you want these actions to be executed: f1 - write to a file f2 - read from that file you need to make sure that f1 always gets evaluated before f2 !!! In Haskell you are never sure ğŸ˜± because eval order is unspecified... The next Haskell will be strict. ~ Simon Peyton Jones Pure functions Pure functions are like mathematical functions, they do calculations, and only return new values (no mutable variables). They are only considering \"insides\" of a program, its own memory. Impure functions Impure functions go beyond our program, they \"go outside\", play and get dirty. They read/write to a file/console/database etc. Haskell wants you not to get dirty, and play as much as you can inside (stay safe). But how does it know which functions are \"impure\"? Well, by marking them with IO wrapper type (which is \"a monad\"). Main function \"Normal\" programming languages have a main function, which usually looks something like this: static void main(String[] args) {\n}\n but in Haskell you have this: main :: IO ()\nmain = ...\n Haskell marks the main as an IO action, so by definition it is impure. History and pre-history Before monads were introduced, main function's type looked like this: main :: [Response] -> [Request]. Example taken from StackOverflow: main :: [Response] -> [Request]\nmain responses =\n    [\n    AppendChan \"stdout\" \"Please enter a Number\",\n    ReadChan \"stdin\",\n    AppendChan \"stdout\" . show $ enteredNumber * 2\n    ]\n    where (Str input) = responses !! 1\n        firstLine = head . lines $ input\n        enteredNumber = read firstLine \n In a nutshell, you had to write all of the impure stuff that your whole program will do as a return value. That is represented as a list of requests: [Request]. Return values from those IO actions are delivered in the [Response] list, that you use inside the program logic. The number of responses is the same as the number of requests you gave. So you have to keep in mind the indices, which is a bummer. What if you add one request in the middle? You'd have to change all indices after it... Which request belongs to which response? That's really hard to see. We can already see that this way of writing a program is very cumbersome, unreadable, and limited. Notice also that the approach above works only because Haskell is lazy! Monads Explained Back to IO t. The IO t is an action that will do some side effects before returning a value of type t. This can be anything: writing to disk, sending HTTP requests etc. Examples of impure functions in Haskell: getChar :: IO Char\nputChar :: Char -> IO ()\n You are probably familiar with some functions that operate on the value inside the IO! For example, we have fmap :: Functor f => (a -> b) -> f a -> f b which transforms the value inside any Functor f (monad is a functor). But what about chaining, sequencing actions one after another? How can we ensure that getChar executes strictly before putChar? Monads to the rescue! Its core function is called flatMap (or bind, or >>= ..): (>>=) :: IO a -> (a -> IO b) -> IO b\n The flatMap function: takes an IO a action takes a function that takes a (the a from IO a) returns a new IO b So there we have it, Monad in all its glory! :) It's \"just\" a semicolon (;), duhh, sequencing operations. Let's see our solution now: echo = getChar >>= putChar\n\n-- or more verbosely\necho = getChar >>= (\\\\c -> putChar c)\n\n-- or verbosiest\necho = (>>=) getChar (\\\\c -> putChar c)\n In Scala you'd write val echo = getChar.flatMap(putChar). This is the reason why Monads were introduced in Haskell. In short, Haskell is the world's finest imperative programming language. ~ Simon Peyton Jones Syntax sugar for Monads Haskell and some other languages have built-in syntax for Monads. Haskell has \"do notation\" and Scala has \"for comprehensions\". It makes them more readable by flipping sides: echo = do\n    c <- getChar\n    putChar c\n Scala: val echo = for {\n    c <- getChar\n    _ <- putChar(c)\n} yield ()\n The <- symbol gets translated into >>= by Haskell's compiler. In case of Scala, it gets turned into a flatMap. It turns out that Monads are useful not only in the IO context, but for other types too. Whenever you have unwanted nesting like Wrapper[Wrapper[T]], you need to \"flatMap that shit\", hence you need a Monad. If you have List[List[String]] you probably needed a flatMap instead of map. If you have Option[Option[String]], same thing. You can imagine doing the same example above with a List[T], where c would be one element of the list. Async / Await After some time it came to my mind that we are doing a similar thing in JS/C#/Kotlin with await. It is almost the same thing, we are \"pulling a value from a Promise/Task\" (~Monads): async function fetchUserMovies() {\n    const user = await fetch('/user');\n    const movies = await fetch(`/user/${user.id}/movies`);\n    console.log(movies);\n    return movies;\n}\n Before this we used to write \"normal callback functions\": function fetchUserMovies() {\n    fetch('/user').then(user => {\n        fetch(`/user/${user.id}/movies`).then(movies => {\n            console.log(movies);\n            return movies;\n        });\n    });\n}\n Seems like then corresponds to flatMap, and await corresponds to <- syntax sugar. Some noticable differences: do/for is general, while await is specific just for Promise do/for in statically typed languages is checked for proper types, while in JS you're on your own My opinions To me, it feels very awkward to program in a lazy programming language. It is hard to reason about and you have to use monads for doing even the simplest IO operations. If you have a pure function and want to println a value.. nope, you gotta wrap everything in an IO.. wack. When used inside a normally strict language like Scala or Java, it \"spreads like a virus\". If you have an IO[String], all code that calls it must be an IO[..]!! It's viral! No bueno! You have to ask yourself: is all that complexity really worth it? IMHO it is not, 99% of the time. Especially today when we have JVM virtual threads. So, in my opinion, use Monads/Rx/whatever only when you have to! The simpler the program - the better. For example, in Java you can use threads and concurrent datastructures. Web servers like Tomcat, Jetty etc. are working just fine with a thread-per-request model. But in JS you don't have that liberty, you need to use Promises. That's because JS doesn't have \"normal threads\", is has only one thread with an event-loop so you have to program asynchronous code. I hope this gave you a better insight into scary Monads and the FP way of handling IO. Additional resources Tackling the Awkward Squad by Simon Peyton Jones Essential Effects by Adam Rosien State of Loom by Ron Pressler (comparing RX vs threads) Future vs IO by Diogo Castro The Observable disguised as an IO Monad by Luis Atencio Benefits of IO discussion on Reddit","title":"You already know Monad(ic) stuff","url":"/en/programming/monads.html"},{"text":"API First Scala There are many ways to build APIs: YOLO approach code-first approach API-first approach YOLO approach In the \"YOLO mode\" you don't care much about the users of your API. Maybe you have a few examples or docs you made, but nothing too serious. Code-first approach In the \"code-first\" approach you start with the coding right away. Schedules are tight, deadlines are near, pressure is real. The specification (if any) is mostly an afterthought. Consider Spring annotations, you can always sprinkle some @ApiParam here and there in your controllers. There are also approaches like Tapir, where you use a Scala DSL to define your API. Then you implement the server logic, and generate the spec from that Scala code. Potentially the client(s) too. This approach is popular, since you start with coding right away. But it has some downsides: you kinda play russian roulette with the spec, since it is generated from the code, so you can't really call it stable it is more code to maintain, increasing your cognitive load and compile times bundle size is increased, since you have to include the dependencies sometimes you have to fight the DSL to get what you want (e.g polymorphic payloads and such) you are limited by what DSL provides, if you need some framework-specific feature, it's challenging to get to it (or impossible) API-first approach In the \"API-first\" approach you start with the API specification. You define the API usually with OpenAPI (Swagger) in a YAML or JSON file. Then you generate the server from that spec (and client code if need be). This approach has some advantages: you are in full control of the spec, it is the source of truth spec is stable and versioned less code to maintain, there is no DSLs or annotations that obfuscate your code you can leverage your framework's features to the max An example in Scala is the Guardrail tool. It generates some server boilerplate code to the target/.../src_managed/main folder (you don't commit this to git). Then you implement the server logic by overriding those abstract definitions, fill in the blanks essentially. Note that when you change the openapi.yaml, the src_managed code is overwritten. Guardrail is a nice approach, sadly it doesn't support Scala 3 yet. A new kid on the block is the OpenApi4s tool that I made. It takes a bit different approach, it doesn't hide the server code from you, it generates it directly in your src folder. Exactly like you would have written it by hand. So how does it handle changes in the spec??? Overwrite the code every time? No, that would be silly, so let's see... OpenApi4s TLDR: OpenApi4s refactors your code automatically, by using regenesca diff+merge library. Generating the models and controllers is the easy part: parse the OpenAPI spec generate models generate controllers and that's it. The hard part is how to handle changes in the spec. Consider the classical PetStore spec. OpenApi4s will generate something like this for the User model: case class User(\n    id: Option[Long],\n    username: Option[String],\n    firstName: Option[String],\n    lastName: Option[String],\n    email: Option[String],\n    password: Option[String],\n    phone: Option[String],\n    userStatus: Option[Int]\n) derives JsonRW\n Adding a new property When you add a new age field of type integer to the User model. OpenApi4s will compare the newly generated case class User (in-memory), with the existing case class User in your source code. Then it will figure out that age: Int parameter is missing, and it will add it. --- a/api/src/com/example/petstore/api/models/User.scala\n+++ b/api/src/com/example/petstore/api/models/User.scala\n@@ -14,5 +14,5 @@ case class User(\n    email: Option[String],\n    password: Option[String],\n    phone: Option[String],\n-  userStatus: Option[Int]\n+  userStatus: Option[Int], age: Long\n    ) derives JsonRW\n Changing a property Let's say you change the userStatus's format from int32 to int64. OpenApi4s will figure out that userStatus: Option[Int] needs to be changed to userStatus: Option[Long]. --- a/api/src/com/example/petstore/api/models/User.scala\n+++ b/api/src/com/example/petstore/api/models/User.scala\n@@ -14,5 +14,6 @@ case class User(\n    email: Option[String],\n    password: Option[String],\n    phone: Option[String],\n-  userStatus: Option[Int]\n+  userStatus: Option[Long]\n Adding a new endpoint Adding a new endpoint to existing controller is easy too. It will just add another case to your existing routes. For example in sharaf framework it will add something like this: case GET -> Path(\"user\", \"new-endpoint\") =>\n    Response.withStatus(StatusCodes.NOT_IMPLEMENTED)\n It will even generate a boilerplate implementation for you. You can then fill in the blanks. Changing an endpoint Now this is a bit more tricky. OpenApi4s must not touch your existing code, since you might have already implemented some logic. So it will not touch your existing expressions, for example Response.withStatus(..) in the previous example. But it will update the query parameters if needed. CI Preventing accidental overwrites You might be cautious about the changes that OpenApi4s makes. Thinking, will it overwrite my code? How can I make sure it doesn't? A simple check you can do in your CI pipeline is to: touch the openapi.yaml file, just so that mill detects a change and triggers openapi4s compile the code, to regenerate the files see if there are any changes in the git diff Example: echo \" \" >> api/resources/openapi.yaml\n./mill api.compile\ntruncate -s -1 api/resources/openapi.yaml\ngit diff --exit-code\n[ $$? -eq 0 ]  || exit 1\n Preventing breaking changes Since the openapi.yaml is now in git, you can do some cool stuff with it. One very useful check is preventing breaking changes. You can do it with openapi-diff for example: git show origin/main:api/resources/public/openapi.json > main_openapi.json\n\ncs launch org.openapitools.openapidiff:openapi-diff-cli:2.1.0-beta.12 -M org.openapitools.openapidiff.cli.Main -- --fail-on-incompatible main_openapi.json ./api/resources/public/openapi.json\n[ $$? -eq 0 ]  || exit 1\n\nrm main_openapi.json\n See the CI script in the openapi4s demo repo. Here is an example of compatible change PR. And an example of breaking change PR, CI fails of course. Conclusion Hope you find this post (and OpenApi4s tool) useful. You can find more tools to combine with api-first approach at https://openapi.tools/ Check out the video demo on YouTube! Additional resources Understanding the API-First Approach Guardrail Tapir Documenting a Spring REST API Using OpenAPI 3.0","title":"API First Scala","url":"/en/programming/api-first-scala.html"},{"text":"This content is not available in your country. Sorry about that. :/ Just kidding, there's nothing here! ^_^ Go back to homepage","title":"Not found","url":"/404.shtml"},{"text":"Varijable Varijable nam sluÅ¾e za spremanje informacija/podataka. Recimo ako raÄunamo prosjeke ocjena uÄenika (npr. ima 29 uÄenika trenutno), morali bi napisati broj 29 viÅ¡e puta u programu. Ako doÄ‘e novi uÄenik, morali bi na svim mjestima u programu izmijeniti 29 na 30... Varijable nam pomaÅ¾u da izbjegnemo ovakve situacije. Svaka varijabla ima naziv i tip. Tip nam ograniÄava Å¡ta moÅ¾emo spremiti u tu varijablu: Integer - cijeli broj Real - realni broj String - tekst Boolean - jeste/nije (engl. true/false) NapraviÄ‡emo program koji Ä‡e izraÄunati obim kvadrata. Za to Ä‡e nam trebati 2 varijable: a: Integer - duÅ¾ina stranice kvadrata obim: Integer - rezultat Deklaracija i dodjela varijable U donjem prozoru uradite sljedeÄ‡e: deklariÅ¡ite varijablu a: kliknite na strelicu odaberite Declare kliknite na novi Declare blok i unesite naziv a. Primijetite da varijabla veÄ‡ ima tip Integer. Kasnije ga moÅ¾emo promijeniti po potrebi. dodijelite vrijednost varijabli a: kliknite na strelicu ispod deklaracije a varijable odaberite Assign kliknite na novi Assign blok i unesite naziv a i vrijednost 5 Ovdje Ä‡emo malo zastati. Prvo probajte ispisati varijablu a na ekran. To smo nauÄili u prethodnoj sekciji! Malo terminologije: deklaracija znaÄi \"uvoÄ‘enje varijable\", kaÅ¾emo programu da Å¾elimo koristiti tu varijablu. Nakon deklaracije, varijabla nema nikakvu vrijednost spremljenu u sebi! (moÅ¾emo joj dati poÄetnu vrijednost, Å¡to je dobra praksa) dodjela varijable (engl. assignment) znaÄi \"dodjela vrijednosti varijabli\" Varijabli moÅ¾emo dodijeliti vrijednost viÅ¡e puta tokom programa! Obim kvadrata NastaviÄ‡emo sa pravljenjem programa za raÄunanje obima kvadrata. DodaÄ‡emo joÅ¡ jednu varijablu, Integer obim koja Ä‡e sadrÅ¾ati rezultat, obim kvadrata. Naravno, varijablama smo mogli dati bilo koji drugi naziv: xyz, fdgfdgfdxcv itd. Ali varijable moraju imati smislene nazive, da bi kasnije mogli lakÅ¡e razumjeti program. DodijeliÄ‡emo varijabli obim ovu vrijednost: a * 4. Kada ispiÅ¡emo obim i pokrenemo program, trebali bi dobiti vrijednost 20.","title":"Varijable","url":"/flowrun/variables.html"},{"text":"Do While petlja Ova naredba je sliÄna While. Glavna razlika je da Do While provjerava uslov tek nakon Å¡to izvrÅ¡i naredbe. Do While Ä‡e izvrÅ¡iti blok naredbi minimalno jednom. NapraviÄ‡emo program koji Äita broj od korisnika, koji mora biti pozitivan: deklariÅ¡ite Integer x dodajte Do While sa uslovom x <= 0 unesite x u tijelu D oWhile Ovaj program moÅ¾emo proÄitati ovako: \"Unesi broj x, dok god je manji ili jednak nuli\" Kada pokrenete program probajte unijeti sljedeÄ‡e vrijednosti: 1, 17, -55, 6. Do While Ä‡e zavrÅ¡iti samo kada unesete pozitivan broj. VjeÅ¾be Unosite String s i ispiÅ¡ite ga, sve dok ne bude jednak \"END\" Unosite jednu po jednu ocjenu dok korisnik ne unese 0. Zatim ispiÅ¡ite prosjek tih ocjena","title":"Do While petlja","url":"/flowrun/do-while.html"},{"text":"If naredba VeÄ‡ smo vidjeli kako program izvrÅ¡ava naredbe jednu nakon druge, odozgo ka dole. Ali uglavnom Ä‡e nam trebati i neko uslovno izvrÅ¡avanje, program Ä‡e morati \"donositi odluke\" tokom izvrÅ¡avanja. NapraviÄ‡emo program koji Ä‡e ispisati da li je broj pozitivan ili negativan: deklariÅ¡ite x: Integer odradite unos x dodajte If blok s vrijednoÅ¡Ä‡u x > 0 u true grani ispiÅ¡ite \"pozitivan\" u false grani ispiÅ¡ite \"negativan\" Npr. ako korisnik unese broj 9, izlaz Ä‡e ispisati \"pozitivan\". Ako korisnik unese -57 ispisaÄ‡e \"negativan\". Izraz x > 0 ima tip Boolean. Boolean moÅ¾e imati vrijednost true ili false. Komplikovaniji uslovi I operator U gornjem primjeru koristili smo izraz x>0 koji je Boolean. Å ta ako nam treba neki komplikovaniji izraz? Npr. ako Å¾elimo povjeriti je li broj pozitivan i manji od 50. Za to nam treba operator \"I\" (engl. \"and\"), koji piÅ¡emo kao &&. Dakle, napisali bi x>0 && x<50. Da se podsjetimo \"tablice istinitosti\" za I operaciju: A B A && B true true true true false false false true false false false false Vidimo da je uslov ispunjen samo kada su oba uslova ispunjena. ILI operator Kada imamo 2 moguÄ‡a uslova, od kojih nam bilo koji odgovara, tada koristimo operator \"ILI\" (engl. \"or\"), koji piÅ¡emo kao ||. Npr. x==\"abc\" || x==\"ABC\" izraz kaÅ¾e da x mora biti jednak \"abc\" ili \"ABC\". Ako je bilo koje od ovo dvoje ispunjeno, i cijeli izraz biÄ‡e ispunjen/istinit. A B A || B true true true true false true false true true false false false NE operator Na kraju, imamo i operaciju negacije, koja samo \"obrne\" vrijednost Booleana. Na bosanskom se Äita \"NE\" (engl. \"not\"), a piÅ¡emo je kao !. Ovaj operator piÅ¡e se prije vrijednosti koju negiramo, npr. !uslov. A !A true false false true","title":"If naredba","url":"/flowrun/ifs.html"},{"text":"Osnove Svaki program ima svoj poÄetak i kraj. PoÄetak je oznaÄen sa Begin, kraj je oznaÄen sa End. Strelica pokazuje na iduÄ‡u naredbu koja se treba izvrÅ¡iti. Ako kliknemo na dugme Run (â–¶), program Ä‡e se pokrenuti i odmah zavrÅ¡iti! Nije se niÅ¡ta znaÄajno desilo, samo vidimo u output panelu da je program zavrÅ¡io. Hajde da ispiÅ¡emo neÅ¡to na ekran: kliknite na strelicu, prikazaÄ‡e se lista naredbi koje moÅ¾emo dodati kliknite na Output kliknite na novu Output naredbu upiÅ¡ite \"Pozdrav svijete!\", sa navodnicima! kliknite Run Program sada ispisuje poruku \"Pozdrav svijete!\" u izlaznom panelu. VjeÅ¾be ÄŒestitam, napisali smo svoj prvi program! Probajte odraditi sljedeÄ‡e vjeÅ¾be: Ispis IspiÅ¡ite 123 na ekran IspiÅ¡ite 12 + 3 na ekran IspiÅ¡ite 3.14 na ekran (brojevi sa zarezom se ustvari piÅ¡u sa taÄkom!) MatematiÄke operacije Naravno, moÅ¾emo raditi matematiÄke operacije nad brojevima. IspiÅ¡ite sljedeÄ‡e izraze: 10 + 3 10 - 3 10 * 3 10 / 3 10 % 3 Zadnja operacija je malkice misteriozna. Ona daje cjelobrojni ostatak pri dijeljenju. Npr. 10 / 3 je 3 i ostatak 1. Tako da je 10 % 3 = 1. Naravno, moÅ¾emo koristiti zagrade ako nam trebaju: (2 + 2) * 2 2 + (2 * 2) Spajanje teksta U prethodnim primjerima ispisivali smo neke jednostavne tekstualne vrijednosti. Nekad nam treba da te vrijednosti spojimo u jednu. Za to nam sluÅ¾i znak +: \"abc\" + \"xyz\" bi ispisalo isto kao i \"abcxyz\" \"abc\" + 5 je isto kao \"abc5\" Probajte razne kombinacije, brojeve sa zarezom itd. Probajte spojiti viÅ¡e od 2 vrijednosti! Malo terminologije: tekst koji se piÅ¡e sa navodnim znacima, npr. \"Meho\" naziva se String broj bez zareza naziva se Integer (engl. \"cijeli broj\") broj sa zarezom/taÄkom naziva se Real (engl. \"realni broj\")","title":"Basics","url":"/flowrun/basics.html"},{"text":"While petlja Kada Å¾elimo da ponovimo dio koda viÅ¡e puta, uvijek moÅ¾emo copy-paste te naredbe. Naravno, to nije uvijek efikasno niti moguÄ‡e. Npr. kada Å¾elimo ponoviti dio koda pod nekim uslovom, moÅ¾e biti 0 ili n puta.. Za to nam sluÅ¾i While naredba/petlja. While ima 2 dijela: uslovni izraz - provjerava se svaki put prije izvrÅ¡avanja tijela petlje tijelo (engl. body) - naredbe koje se izvrÅ¡avaju kada je uslov ispunjen NapraviÄ‡emo program koji ispisuje brojeve od 1 do 5: deklariÅ¡ite Integer x = 1 dodajte While sa uslovom x <= 5 ispiÅ¡ite x u tijelu While dodijelite x = x + 1 nakon ispisa Kada pokrenete program trebali bi vidjeti brojeve 1,2,3,4,5 ispisane na izlaznom panelu. Primijetite da smo u dodjeli x = x + 1 koristili prethodnu vrijednost x-a! U izrazu x+1, x se odnosi na zadnju vrijednost prije ove naredbe. VjeÅ¾be IspiÅ¡ite brojeve od 1..20 koji su djeljivi sa 3 Za uneseni n ispiÅ¡ite sljedeÄ‡e drvo (primjer za n=4): 1 22 333 4444","title":"While petlja","url":"/flowrun/while.html"},{"text":"Rekurzivne funkcije Sada se pripremite za neÅ¡to od Äega Ä‡e vas zaboljeti glava. Nemojte se brinuti ako ne \"skopÄate\" odmah ovaj koncept, Äak ni neki dugogodiÅ¡nji programeri \"nisu naÄisto\" sa rekurzijom. :) Funkcije mogu pozivati funkcije! Da.. to smo veÄ‡ vidjeli, \"main\" je pozvao funkciju \"kvadrat\". Ali Å¡ta ako funkcija pozove samu sebe!?? Da, i to je moguÄ‡e, i vrlo korisno u nekim sluÄajevima. NapisaÄ‡emo rekurzivnu funkciju koja odbrojava od x do 1: dodajte novu funkciju countdown dodajte joj parametar Integer x dodajte If sa uslovom x > 0 ispiÅ¡ite x u true grani pozovite countdown(x-1) nakon ispisa pozovite countdown(5) u main funkciji Pokrenite program, ispisaÄ‡e 5, 4, 3, 2, 1. Kako ova magija radi?? Kada je countdown pozvana sa argumentom 5, ispisaÄ‡e ga i pozvati countdown(4). Zatim Ä‡e ispisati 4 i pozvati countdown(3). Zatim Ä‡e ispisati 3 i pozvati countdown(2). Zatim Ä‡e ispisati 2 i pozvati countdown(1). Zatim Ä‡e ispisati 1 i pozvati countdown(0). U ovom trenutku uslov Ä‡e biti false tako da Ä‡e se funkcija zavrÅ¡iti. Tek kada se ovaj poziv funkcije zavrÅ¡i, kreÄ‡e se sa \"odmotavanjem\": zavrÅ¡iÄ‡e se poziv countdown(1) zavrÅ¡iÄ‡e se poziv countdown(2) zavrÅ¡iÄ‡e se poziv countdown(3) zavrÅ¡iÄ‡e se poziv countdown(4) zavrÅ¡iÄ‡e se poziv countdown(5) zavrÅ¡iÄ‡e se main Najbitniji dio je bazni/zavrÅ¡ni sluÄaj tj. uslov zavrÅ¡etka rekurzije. To je ova false grana, jer npr. kad ne bi imali ovaj If uslov, rekurzija se nikad ne bi zavrÅ¡ila. U tom sluÄaju program bi se zaledio i morali bismo ga zaustaviti (klikom na Stop dugme). MoÅ¾ete probati pozvati main u mainu, doÄ‡i Ä‡e do beskonaÄne rekurzije.","title":"Rekurzivne funkcije","url":"/flowrun/recursive-functions.html"},{"text":"For petlja Ova naredba je malo komplikovanija. For petlja sadrÅ¾i sljedeÄ‡e dijelove: naziv varijable poÄetna vrijednost - start krajnja vrijednost - end inkrement/korak - step tijelo/naredbe IzvrÅ¡avanje For petlje je isto kao sljedeÄ‡e: Deklarisanje i: Integer sa poÄetnom vrijednoÅ¡Ä‡u While petlja sa uslovom i <= end i tijelom Assign i = i + step na kraju While NapraviÄ‡emo program isti kao za While petlju, printanje prvih 5 brojeva: deklariÅ¡ite For petlju sa varijablom i poÄetna vrijednost je 1 krajna vrijednost je 5 korak je 1 ispiÅ¡ite i u tijelu For petlje Postigli smo isti rezultat kao sa While, samo sa dosta manje koda! Plus, ovako je dosta Äitljivije. VjeÅ¾be IspiÅ¡ite svako 5-i broj od 0..50 IspiÅ¡ite tablicu mnoÅ¾enja od 1 do 10 IzraÄunajte faktorijel broja 7","title":"For petlja","url":"/flowrun/for.html"},{"text":"Povratna vrijednost funkcije U prethodnom dijelu vidjeli smo kako moÅ¾emo grupisati dio koda u funkciju. Funkciju moÅ¾emo parametrizovati sa argumentima kada ju pozivamo. Funkcije takoÄ‘er mogu da vrate vrijednost. Hajde da napravimo funkciju kvadrat(x). IzraÄunat Ä‡e kvadrat broja x i vratiti ga kao vrijednost: dodajte novu funkciju kvadrat sa tipom Integer dodajte novi parametar Integer x kliknite na return element i upiÅ¡ite x*x u main funkciji ispiÅ¡ite kvadrat(5) Program Ä‡e ispisati 25 kada ga pokrenete.","title":"Povratna vrijednost funkcije","url":"/flowrun/return-of-functions.html"},{"text":"UgraÄ‘ene funkcije Vidjeli smo kako izraÄunati jednostavne matematiÄke izraze sa operatorima +, -, *, / i %. Za Boolean izraze imamo operatore &&, || i !. Za Stringove imamo operator +, koji ih nadovezuje, \"Å¡tikla\" ih. U \"pravim\" programima ne izmiÅ¡ljamo toplu vodu, veÄ‡ iskoriÅ¡tavamo postojeÄ‡i kod. Taj kod moÅ¾e biti \"ugraÄ‘en\" u sami jezik, ili kod koji smo mi napisali. Moramo negdje \"spremiti\" taj kod, parametrizirati ga ako je potrebno. Za to nam sluÅ¾e funkcije! Hajde da vidimo neke od ugraÄ‘enih/predefinisanih funkcija. Probajte ispisati sljedeÄ‡e izraze: abs(-456.31) real2int(3.14) length(\"abcd\") randomInt(10) Sintaksa je ista kao i u matematici, napiÅ¡emo ime funkcije, a u zagradama navedemo argumente koji su razdvojeni zarezom. Gornji izrazi se nazivaju \"pozivanje funkcije\" (engl. \"invoke\").","title":"UgraÄ‘ene funkcije","url":"/flowrun/predefined-functions.html"},{"text":"Definisanje funkcije Predefinisane funkcije su super. Ali joÅ¡ bolje je kada znamo napisati svoju funkciju! Prije nego nastavimo, moram spomenuti da veÄ‡ imamo jednu funkciju koja se zove \"main\". Ova funkcija je vrlo vaÅ¾na, jer je ona funkcija od koje poÄinje izvrÅ¡avanje programa kada pritisnete Play. Hajde da definiÅ¡emo funkciju pozdrav(ime): dodajte novu funkciju u lijevom panelu kliknite na fun1 na dijagramu i promijenite ime u pozdrav kliknite + da dodate novi parametar String ime ispiÅ¡ite \"Pozdrav \" + ime kliknite na main funkciju dodajte novu Call naredbu i upiÅ¡ite pozdrav(\"Meho\") Program bi trebao ispisati Pozdrav Meho.","title":"Definisanje funkcije","url":"/flowrun/custom-functions.html"},{"text":"Unos podataka U prethodnim primjerima koristili smo vrijednosti koje su ufiksane u program. Npr. vrijednost 5 za duÅ¾inu stranice kvadrata. Bilo bi zgodno kada bi mogli dati korisniku da unese proizvoljnu vrijednost. Naravno, to je moguÄ‡e, i za to sluÅ¾i naredba Input. U donjem prozoru uradite sljedeÄ‡e: deklariÅ¡ite varijablu ime: String nakon nje dodajte Input naredbu kliknite na novu Input naredbu i unesite ime. Ovo znaÄi da kada program doÄ‘e do ove linije, pitaÄ‡e korisnika da unese svoje ime. Vrijednost koju korisnik upiÅ¡e program Ä‡e spremiti u varijablu ime ispiÅ¡ite ime Program sada Äeka da unesemo neki tekst. Unesite svoje ime i kliknite Enter. Vidimo da program odgovara ispisom u izlaznom panelu. VjeÅ¾be Izmijeniti primjer sa kvadratom, omoguÄ‡iti korisniku da unese duÅ¾inu stranice. Napraviti program za unos 2 stranice pravougaonika, zatim ispisati njegov obim.","title":"Unos podataka","url":"/flowrun/user-input.html"},{"text":"Teorija skupova Teorija skupova (en. Set theory) je jedna od osnovnih grana matematike. Ona, izmeÄ‘u ostalog, daje odgovor na to da li neki objekat pripada datom skupu objekata. Skup mora biti jasno i nedvosmisleno definisan. Skup kao pojam se obiÄno ne definiÅ¡e veÄ‡ se uzima kao osnovni pojam (aksiom). To je ustvari samo kolekcija/mnoÅ¡tvo razliÄitih objekata (stvari). Objekat koji pripada skupu naziva se element skupa. Element skupa moÅ¾e biti bilo Å¡ta, npr. broj, jabuka, avion, ili Äak skup! Vidimo da su skupovi vrlo liberalni, pa se Äesto koriste u raznim oblastima matematike i nauke. Skupovi se oznaÄavaju velikim Å¡tampanim slovima: AAA, BBB, ... a elementi malim slovima xxx, yyy, ... Definicija se navodi u vitiÄastim zagradama, npr. A={1,2,3}A=\\{1,2,3\\}A={1,2,3}. Redoslijed elemenata nije bitan: A={1,2,3}={3,2,1}={2,1,3}A=\\{1,2,3\\} = \\{3,2,1\\} = \\{2,1,3\\}A={1,2,3}={3,2,1}={2,1,3}. Zato se kaÅ¾e da je skup neureÄ‘ena kolekcija. Ne postoji prvi, drugi element i sl. ObiÄno se u matematici koristi neko pravilo koje elementi moraju zadovoljavati (umjesto navoÄ‘enja elemenata pojedinaÄno...), npr. \"skup svih prirodnih brojeva koji su manji od 5\". To moÅ¾emo zapisati ovako: {xâˆ£xâˆˆN,x<5}\\{x | x \\in \\mathbb{N}, x \\lt 5\\}{xâˆ£xâˆˆN,x<5}. Ovdje xxx oznaÄava neki element skupa, âˆ£|âˆ£ se Äita kao \"takav da je\", a zarez se Äita kao logiÄko \"i\" (en. and). Negdje se koristi i dvotaÄka umjesto | znaka, npr. {x:xâˆˆN,x<5}\\{x : x \\in \\mathbb{N}, x \\lt 5\\}{x:xâˆˆN,x<5}. Dva skupa su jednaka akko imaju iste elemente. To piÅ¡emo kao A=BA=BA=B, logiÄno... :D Ovo \"akko\" je skraÄ‡eno od \"ako i samo ako\" (en. iff - if and only if). Razlika izmeÄ‘u \"ako\" i \"akko\" je sljedeÄ‡a: Kada kaÅ¾emo \"ako A onda B\" ne mora znaÄiti da \"ako B onda A\"! Ali, kada kaÅ¾emo \"akko A onda B\" tada MORA biti i \"akko B onda A\"! Primjer: Kod iskaza \"Ako grije Sunce onda je dan.\" ne mora znaÄiti da ako je dan da grije Sunce... MoÅ¾da je oblaÄno! Vidimo da ovdje ne moÅ¾emo koristiti akko. Dok npr. iskaz \"Trougao je jednakostraniÄni akko su mu svi uglovi od 60o60^o60o\" je validan. ZaÅ¡to? Zato Å¡to vrijedi i obrnuto, ako su svi uglovi trougla od 60o60^o60o onda je on jednakostraniÄni. LogiÄno. Postoji nekoliko skupova koji se Äesto pojavljuju u matematici i imaju posebne simbole: âˆ…\\emptysetâˆ… - Prazan skup. Skup koji ne sadrÅ¾i nijedan element. OznaÄava se i sa {}\\{\\}{}. N\\mathbb{N}N - Skup prirodnih brojeva (od en. Natural - prirodni). N={0,1,2,...}\\mathbb{N} = \\{0,1,2,...\\}N={0,1,2,...}. Neki autori ne ukljuÄuju nulu u ovaj skup. Zato kada se Å¾eli posebno istaÄ‡i da je i nula ukljuÄena koriste se simboli N0N_0N0, N0N^0N0. Kada se Å¾eli istaÄ‡i da nula nije ukljuÄena piÅ¡e se N+={1,2,...}N^+ = \\{1,2,...\\}N+={1,2,...}. Analogna notacija vrijedi i za ostale skupove. Z\\mathbb{Z}Z - Skup cijelih brojeva (od njem. Zahl - broj, en. integer). Z={0,1,âˆ’1,2,âˆ’2,...}\\mathbb{Z} = \\{0,1,-1,2,-2,...\\}Z={0,1,âˆ’1,2,âˆ’2,...}. Q\\mathbb{Q}Q - Skup racionalnih brojeva (od en. Quotient - razlomak). Svaki broj koji moÅ¾e biti predstavljen razlomkom pq\\frac{p}{q}qp gdje su ppp i qqq dva cijela broja. Naravno, qqq ne smije biti nula jer bi dijeljenjem dobili âˆ\\inftyâˆ (beskonaÄno)... R\\mathbb{R}R - Skup realnih brojeva (od en. Real - pravi). Za nas obiÄne smrtnike ovo su \"brojevi sa zarezom\". C\\mathbb{C}C - Skup kompleksnih brojeva (od en. Complex - sloÅ¾eni). To su brojevi koji pored realnog sadrÅ¾e i imaginarni dio. Kada neki element xxx pripada skupu AAA to piÅ¡emo sa xâˆˆAx \\in AxâˆˆA. Npr. 1âˆˆ{2,1}1 \\in \\{2,1\\}1âˆˆ{2,1}. Kada neki element xxx ne pripada skupu AAA to piÅ¡emo sa xâˆ‰Ax \\notin Axâˆˆ/A. Kako smo veÄ‡ rekli, skup moÅ¾e sadrÅ¾ati bilo Å¡ta. Da vidimo par zanimljivih primjera: Ako imamo skup A={{1,2},{2,3},4}A = \\{\\{1,2\\},\\{2,3\\},4\\}A={{1,2},{2,3},4} tada 1âˆ‰A1 \\notin A1âˆˆ/A. ZaÅ¡to? Pa zato Å¡to 111 nije direktno u skupu! Skup AAA sadrÅ¾i dva skupa i broj 444! Za bilo koje xxx vrijedi xâˆ‰âˆ…x \\notin \\emptysetxâˆˆ/âˆ…. Ili napisano hijeroglifima: âˆ€x,xâˆ‰âˆ…\\forall x, x \\notin \\emptysetâˆ€x,xâˆˆ/âˆ…. Ako imamo A={âˆ…}A = \\{\\emptyset\\}A={âˆ…} vrijedi âˆ…=Ì¸A\\emptyset \\not = Aâˆ…î€ =A. Å taaa? A je skup koji sadrÅ¾i prazan skup. Å to nije isto kao i prazan skup. Simbol âˆ€\\forallâˆ€ znaÄi \"za svako\". Npr. âˆ€x,tvrdnja\\forall x, tvrdnjaâˆ€x,tvrdnja se Äita kao \"za svako x vrijedi tvrdnja\". U paru ide i simbol âˆƒ\\existsâˆƒ koji se Äita kao \"postoji (bar jedno)\" ili \"ima\". Operacije nad skupovima PoÅ¡to element skupa moÅ¾e biti bilo Å¡ta, obiÄno se ograniÄavamo samo na odreÄ‘eni tip stvari tj. na neki skup. Npr. kada govorimo o cijelim brojevima ne zanimaju nas imaginarni brojevi, jabuke i auta... Skup stvari o kojima se trenutno govori naziva se univerzalni skup, ili kraÄ‡e univerzum. OznaÄava se sa UUU. Skupovi i relacija (odnosi) izmeÄ‘u skupova se mogu grafiÄki predstaviti Venovim dijagramom. Na slici desno vidimo primjer s dva skupa: A={1,2,4}A = \\{1,2,4\\}A={1,2,4} i B={2,3}B = \\{2,3\\}B={2,3}. Univerzum ( UUU) je pravougaonik koji obuhvata ova dva skupa. Recimo da je to skup N\\mathbb{N}N. To je igraliÅ¡te iz kojeg ne smijemo izlaziti. Unija Unija dva skupa AAA i BBB oznaÄava se sa AâˆªBA \\cup BAâˆªB. Primijetite da ovo nije obiÄno slovo U veÄ‡ specijalni simbol, mada izgleda kao âˆª\\cupâˆªnija. Unija predstavlja novi skup koji sadrÅ¾i sve elemente skupa AAA i sve elemente skupa BBB. U naÅ¡em primjeru to bi bilo AâˆªB={1,2,3,4}A \\cup B = \\{1,2,3,4\\}AâˆªB={1,2,3,4}. Skup ne mora bit predstavljen krugom, niÄ‘e veze... xD Dobro zapaÅ¾anje! Uniju moÅ¾emo formalno zapisati kao AâˆªB={xâˆ£xâˆˆAâˆ¨xâˆˆB}A \\cup B = \\{x | x \\in A \\lor x \\in B\\}AâˆªB={xâˆ£xâˆˆAâˆ¨xâˆˆB}. Znak âˆ¨\\lorâˆ¨ se Äita kao \"ili\". Znak âˆ§\\landâˆ§ se Äita kao \"i\". O logiÄkim operatorima Ä‡emo reÄ‡i neÅ¡to viÅ¡e u iduÄ‡em poglavlju. Presjek ÄŒesto se postavlja pitanje Å¡ta dva skupa imaju zajedniÄko. Presjek dva skupa AAA i BBB oznaÄava se sa Aâˆ©BA \\cap BAâˆ©B. Presjek predstavlja novi skup koji sadrÅ¾i one elemente koji se nalaze i u AAA skupu i u BBB skupu. U naÅ¡em primjeru to bi bilo Aâˆ©B={2}A \\cap B = \\{2\\}Aâˆ©B={2} (na slici obojeno crvenom bojom!). Presjek moÅ¾emo formalno zapisati kao Aâˆ©B={xâˆ£xâˆˆAâˆ§xâˆˆB}A \\cap B = \\{x | x \\in A \\land x \\in B\\}Aâˆ©B={xâˆ£xâˆˆAâˆ§xâˆˆB}. Å ta ako skupovi nemaju niÅ¡ta zajedniÄko? Rezultat je, naravno, prazan skup, âˆ…\\emptysetâˆ… tj. {}\\{\\}{}. Prazan skup ipak ima neku svrhu... :D Za ovakve skupove, koji nemaju zajedniÄke elemente, kaÅ¾e se da su disjunktni. Matematika se Äesto bavi pitanjem jednakosti, kako moÅ¾emo jednu te istu stvar izraziti na viÅ¡e naÄina. Ti rezultati nam mogu koristiti za skraÄ‡ivanje algebarskih izraza, optimizacije i sl. Za uniju moÅ¾emo reÄ‡i da je komutativna. Vrijedi da je AâˆªB=BâˆªAA \\cup B = B \\cup AAâˆªB=BâˆªA, Å¡to nije teÅ¡ko razumjeti. TakoÄ‘er, ova operacija je i asocijativna. Vrijedi da je Aâˆª(BâˆªC)=(AâˆªB)âˆªCA \\cup (B \\cup C) = (A \\cup B) \\cup CAâˆª(BâˆªC)=(AâˆªB)âˆªC, tj. redoslijed nije bitan. Sada moÅ¾emo pisati i AâˆªBâˆªCA \\cup B \\cup CAâˆªBâˆªC... Sve navedeno vrijedi i za operaciju presjek! Razlika MoÅ¾emo postaviti i pitanje u Äemu se skup AAA razlikuje od skupa BBB. Ova operacija se naziva razlika. Razlika skupova AAA i BBB oznaÄava se sa A BA \\ BA B. ÄŒita se kao \"A razlika B\". Razliku Äine elementi skupa AAA koji se ne nalaze skupu BBB. U naÅ¡em primjeru to bi bilo A B={1,4}A \\ B = \\{1,4\\}A B={1,4}. Razliku moÅ¾emo formalno zapisati kao Aâˆ–B={xâˆ£xâˆˆAâˆ§xâˆ‰B}A \\setminus B = \\{x | x \\in A \\land x \\notin B\\}Aâˆ–B={xâˆ£xâˆˆAâˆ§xâˆˆ/B}. Postoje joÅ¡ dvije zanimljive operacije, prva je simetriÄna razlika ( Î”\\DeltaÎ”). SimetriÄna razlika predstavlja uniju razlika skupova AAA i BBB, tj. AÎ”B=(A B)âˆª(B A)A \\Delta B = (A \\ B) \\cup (B \\ A)AÎ”B=(A B)âˆª(B A). Kroz naÅ¡ primjer bilo bi AÎ”B={1,3,4}A \\Delta B = \\{1,3,4\\}AÎ”B={1,3,4} Druga operacija je komplement skupa. Komplement skupa AAA su svi elementi koji nisu u skupu AAA, tj. Aâ€¾={xâˆˆUâˆ£xâˆ‰A}\\overline{A} = \\{x \\in U | x \\notin A\\}A={xâˆˆUâˆ£xâˆˆ/A}, gdje je UUU neki univerzum. Negdje se naziva i apsolutni komplement. Kroz naÅ¡ primjer bilo bi Aâ€¾={0,3,5,6,...}\\overline{A} = \\{0,3,5,6,...\\}A={0,3,5,6,...}, pri Äemu je U=NU=\\mathbb{N}U=N. Druge oznake su Aâ€²A'Aâ€² i ACA^CAC. De Morganovi zakoni Dvije vrlo korisne formule vezane za komplemente skupova su De Morganovi zakoni: AâˆªBâ€¾=Aâ€¾âˆ©Bâ€¾\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B}AâˆªB=Aâˆ©B Aâˆ©Bâ€¾=Aâ€¾âˆªBâ€¾\\overline{A \\cap B} = \\overline{A} \\cup \\overline{B}Aâˆ©B=AâˆªB Relacije izmeÄ‘u skupova Kao Å¡to smo veÄ‡ rekli na poÄetku, skupovi su odreÄ‘eni samo elementima koje sadrÅ¾e. To nam je dovoljno da odredimo da li su dva skupa jednaka, A=BA = BA=B akko âˆ€xâˆ£xâˆˆAâˆ§xâˆˆB\\forall x | x \\in A \\land x \\in Bâˆ€xâˆ£xâˆˆAâˆ§xâˆˆB. Podskup i nadskup Za skup AAA kaÅ¾emo da je podskup skupa BBB ako su svi elementi skupa AAA takoÄ‘er elementi skupa BBB. Ako je AAA podskup od BBB piÅ¡emo AâŠ†BA \\subseteq BAâŠ†B. (Znak âŠ†\\subseteqâŠ† podsjeÄ‡a na â‰¤\\leâ‰¤, zar ne?) Da, moÅ¾e biti i sluÄaj da je A=BA=BA=B! Ako A=Ì¸BA \\not = BAî€ =B (nisu isti skupovi) i AâŠ†BA \\subseteq BAâŠ†B tada za AAA kaÅ¾emo da je pravi podskup skupa BBB. PiÅ¡e se AâŠ‚BA \\subset BAâŠ‚B. Analogno, imamo i relaciju nadskup ( AâŠ‡BA \\supseteq BAâŠ‡B) za koju vrijedi obrnuto od relacije podskup. Kakav je sluÄaj sa praznim skupom? Da li je âˆ…âŠ†A\\emptyset \\subseteq Aâˆ…âŠ†A? Primijenimo definiciju: \"Svaki element âˆ…\\emptysetâˆ… (a nema nijedan) je element skupa AAA. Hm, zanimljivo fakat... Imamo dvije opcije: Jeste, jer nema nijedan element skupa âˆ…\\emptysetâˆ… koji nije element skupa A.A.A. Nije, jer nema nijedan element skupa âˆ…\\emptysetâˆ… koji je element skupa A.A.A. LogiÄari kaÅ¾u da jeste (prva opcija) i vjerovaÄ‡emo im na rijeÄ... xD KaÅ¾u da je ovo primjer \"prazne istine\" jer za prazan skup moÅ¾emo tvrditi Å¡ta god Å¾elimo... Otprilike. Kardinalnost skupa Kardinalnost skupa je mjera broja elemenata nekog skupa. Npr. naÅ¡ skup A={1,2,4}A = \\{1,2,4\\}A={1,2,4} ima 3 elementa. PiÅ¡emo âˆ£Aâˆ£=3|A|=3âˆ£Aâˆ£=3. Kod konaÄnih skupova, kardinalnost je obiÄni broj, dok je kod beskonaÄnih.. kako-kad, komplikovano je! NeÄ‡emo u detalje. ReÄ‡i Ä‡emo samo da postoji viÅ¡e beskonaÄnosti! Npr. âˆ£Nâˆ£=Ì¸âˆ£Zâˆ£|\\mathbb{N}| \\not = |\\mathbb{Z}|âˆ£Nâˆ£î€ =âˆ£Zâˆ£. Ne zaboravimo i âˆ£âˆ…âˆ£=0|\\emptyset|=0âˆ£âˆ…âˆ£=0, naravno.","title":"Teorija skupova","url":"/maths/set_theory.html"},{"text":"Paradigme programiranja Jedan od znaÄajnijih problema koje p.j. pokuÅ¡avaju rijeÅ¡iti je kompleksnost. Kako programi postaju veÄ‡i, to su komplikovaniji za razumjeti. Zato danas imamo nekoliko paradigmi (pristupa, naÄina) za razvijanje programa, od kojih su najpoznatije: proceduralno funkcionalno - FP objektno orijentisano - OOP Dosta jezika danas je miks dvije ili viÅ¡e ovih paradigmi. Ove paradigme usmjeravaju naÅ¡ naÄin razmiÅ¡ljanja o problemima po svom nekom Å¡ablonu/fazonu. Npr. kod proceduralnog/imperativnog naÄina razmiÅ¡ljanja mijenjamo varijable \"u mjestu\". Ovdje moramo pamtiti/zamisliti koja je vrijednost neke varijable u datom trenutku, Å¡to je veÄ‡ini ljudi izazovan zadatak. Kod FP/matematiÄkog naÄina razmiÅ¡ljanja pravimo nove varijable a stare ne diramo! To nam pomaÅ¾e kod razumijevanja odreÄ‘enog dijela koda, ne moramo pamtiti u glavi stanje \"cijelog svijeta\" i na Å¡ta utiÄe promjena date varijable. OOP objedinjuje podatke sa funkcijama(metodama) koje rade sa tim podacima. Taj objedinjeni koncept naziva se objekat. OOP nam pomaÅ¾e i da sakrijemo neke podatke i funkcije za koje korisnici(drugi dijelovi koda) ne moraju znati. Ovdje veliku ulogu ima kompajler koji nas ograniÄava i usmjerava nas u tim sluÄajevima. OOP Ovo Å¡to smo do sada radili u Javi je proceduralno programiranje. Koristili smo procedure/funkcije i mijenjali varijable u mjestu. Klase smo koristili da kreiramo objekte koji sadrÅ¾e samo podatke. U OOP klase Ä‡emo koristiti na malo fleksibilniji naÄin.","title":"Paradigme programiranja","url":"/programming/paradigms.html"},{"text":"Programerska Terminologija deklaracija Za liniju int i; kaÅ¾emo da je deklaracija varijable i. Njome uvodimo novo ime u naÅ¡em programu, u ovom sluÄaju varijablu. U suÅ¡tini, samo kaÅ¾emo da postoji ta varijabla. MoÅ¾e se deklarisati i metoda, klasa, interfejs i sl. definicija Linija i = 5; je definicija varijable i. Ovdje navodimo Å¡ta ustvari jeste ta varijabla (ili metoda, klasa, Å¡tagod). izraz (expression) Izraz je neÅ¡to Å¡to ima vrijednost. Bio to broj, string ili neki objekat. Npr. 2 + 2 je izraz. Poziv metode koja vraÄ‡a vrijednost je izraz, npr. obj.getString(). Naravno, svaki izraz moÅ¾emo dodijeliti nekoj varijabli i sl. izjava (statement) Za razliku od izraza, izjave nemaju vrijednost (ili imaju beskorisnu vrijednost, npr. Unit u Scali). Npr. za i = 5; i System.out.println(i); kaÅ¾emo da su izjave. Neke izjave koriste sintaksu ugraÄ‘enu u sami jezik, npr. dodjela vrijednosti (znak jednako: =). Ostale naredbe obiÄno imaju naziv u imperativnom obliku: \"print\", \"calculate\", \"uradiOvo\"... Zato se za Javu i sliÄne jezike kaÅ¾e da su imperativni jezici (jer preferiraju ovaj stil programiranja).","title":"Untitled","url":"/programming/terminology.html"},{"text":"Filozofija programiranja Mi ljudi za sebe tvrdimo da smo inteligentna biÄ‡a. Jedan od dokaza za to je i mnoÅ¡tvo naÅ¡ih naÄina komunikacije. Komunikacija podrazumijeva razmjenu informacija izmeÄ‘u dva ili viÅ¡e uÄesnika (ne moraju biti ljudi), koristeÄ‡i zajedniÄke znakove i pravila. U ovo se ubrajaju audio metode (govor, muzika), vizuelne metode (znakovni jezici, grimase, kolutanje oÄima), fiziÄke metode (kad vas neko udari jer ste nepristojni npr.). Danas u svijetu postoji viÅ¡e od 5.000 jezika, od kojih veÄ‡ina, naÅ¾alost, lagano izumire. Ljudi priÄaju i sa robotima, ako niÅ¡ta gledali ste futuristiÄke filmove. Za nas ljude to je idealan naÄin za komuniciranje. MeÄ‘utim, maÅ¡ine su u suÅ¡tini vrlo glupe, nemaju inteligenciju kao Å¾iva biÄ‡a. MaÅ¡ine nemaju mozak, tijelo, uÅ¡i, glasne Å¾ice... Sve im to moramo obezbijediti, da bi bile \"inteligentne\". Neki od tih organa su predstavljeni kompjuterom, mehaniÄkim dijelovima, mikrofonom, zvuÄnikom itd. Kompjuter je mozak maÅ¡ine, on upravlja svime. Na njega su povezani svi ostali ureÄ‘aji (organi). Nama ljudima misli dolaze same od sebe (veÄ‡ini, neki ljudi ne misle nikako), ali kompjuterima ne. I to im moramo \"ruÄno\" unijeti... Te kompjuterske misli su ustvari naÅ¡e naredbe, koje se skupno nazivaju program. Ovdje smo da nauÄimo neke od naÄina za komuniciranje sa kompjuterima. Naime, ljudi su razvili na stotine programskih jezika koje se koriste za pisanje kompjuterskih programa. Ovi jezici su sliÄni naÅ¡im jezicima, imaju svoju sintaksu, gramatiku i pravopis. Apstrakcije Kroz Å¾ivot, svjesno ili nesvjesno, nauÄili smo koristiti apstrakcije. Apstrakcija je ustvari generalizovanje, uopÄ‡avanje neÄeg konkretnog. U datom kontekstu bitna su nam samo neka svojstva datog objekta/stvari/koncepta. Naprimjer kada kaÅ¾emo automobil, podrazumijevamo neÅ¡to sa 4 toÄka, motorom itd. To je apstraktni automobil, njegova takoreÄ‡i definicija, dok je konkretan automobil npr. komÅ¡ijin Peugeot 307, iz 2001. godine. U fizici i hemiji imamo apstrakciju atoma. Zatim se uvodi apstrakcija molekule, koja se sastoje od viÅ¡e atoma. Kada se govori o molekulama, znamo da su \"ispod\" atomi, ali nas u datom kontekstu to ne zanima! Kontekst predstavlja skup okolnosti i Äinjenica, joÅ¡ jedna vrlo bitna stvar kada se govori o apstrakcijama. U matematici imamo apstrakciju broja. Kada kaÅ¾emo broj obiÄno mislimo na cijeli broj. Ali ne kaÅ¾emo koji broj!? Dakle, samo znamo da mislimo na neki broj. Programi Da ponovimo, program je niz naredbi koje raÄunar treba izvrÅ¡iti, u cilju dobijanja nekog rezultata. Kako svi ljudi razmiÅ¡ljaju na sebi svojstven naÄin, postoji teoretski beskonaÄno mnogo rjeÅ¡enja (programa) za jedan te isti problem! Programi Äesto komuniciraju i sa \"vanjskim svijetom\". Npr. ako trebamo uÄitati neki tekstualni fajl i prebrojati sve rijeÄi, taj fajl nije dio programa veÄ‡ je ulaz (en. input) u naÅ¡ program. Isto vrijedi i za klik miÅ¡a, unos sa tastature, mikrofona i sl. Kada Å¾elimo ispisati neÅ¡to na ekran, pustiti muziku na zvuÄnik, to se zove izlaz (en. output) iz naÅ¡eg programa. Naravno, da ne bismo \"izmiÅ¡ljali toplu vodu\" moÅ¾emo se okoristiti znanjem steÄenim kroz ljudsku historiju. Ljudi su nadoÅ¡li na koncept algoritma, koji predstavlja nedvosmislenu specifikaciju za rjeÅ¡avanje nekog problema. Tj. algoritam je niz precizno definisanih koraka za dobijanje nekog rezultata. LaiÄki reÄeno, to je recept za implementaciju neke funkcije. U toku pisanja koda nekog programa Äesto Ä‡e nam se pojavljivati greÅ¡ke. Tj. program se izvrÅ¡ava ali ne radi kako bismo Å¾eljeli. Te greÅ¡ke se nazivaju bagovi (en. bug - buba, insekt). Za program koji ima takve greÅ¡ke kaÅ¾e se da je bagovit. Proces u kojem traÅ¾imo greÅ¡ke i ispravljamo ih naziva se debagovanje.","title":"Untitled","url":"/programming/philosophy.html"},{"text":"Uvod u Scalu Scala je prije svega potpuno objektno orijentisan jezik. To znaÄi da su sve vrijednosti u programu objekti, Äak i brojevi i karakteri! Ovo nije sluÄaj u Javi, gdje imamo 7 \"primitivnih tipova\" kao Å¡to su int, char, boolean... U Scali su oni predstavljeni klasama Int, Char, Boolean... U C# je sliÄan sluÄaj kao i u Scali, gdje je int samo alijas za Int32, ali je i dalje klasa. Ovaj koncept se naziva i \"unified types\". Da pogledamo deklaraciju konstante: val x: Int = 5\n Tip se piÅ¡e nakon naziva varijable, kao u Pascalu. U veÄ‡ini sluÄajeva kompajler nam moÅ¾e pomoÄ‡i s \"zakljuÄivanjem tipa\" (type inference). Kompajler Ä‡e skontat za nas da je to broj! Tako da je prethodni primjer ekvivalentan sljedeÄ‡em: val x = 5\n Primijetite i to da taÄkazarez nije potrebna! Napokon!!! Izgleda da su pisci kompajlera vrlo lijeni ljudi... :D S razlogom, naravno. KljuÄna rijeÄ val (skraÄ‡eno od value) oznaÄava konstantu, isto kao final u Javi: final int x = 5;\n Naravno, sljedeÄ‡i kod se neÄ‡e iskompajlirati. DobiÄ‡emo greÅ¡ku \"reassignment to val\". val x = 5\nx = 6\n Da vidimo sada dobru staru varijablu, koja se deklariÅ¡e s var, logiÄno: var y = 5\ny = 6\ny += 3\n Varijabla y na kraju ima vrijednost 9. U Scali imamo joÅ¡ jednu vrstu varijable, tzv. \"lijena konstanta\" (lazy value): lazy val z = 5\n Vrijednost lazy val Ä‡e se izraÄunati samo jednom, i to tek kada se pozove u programu! Npr. ako z poziva neku funkciju koja sadrÅ¾i println, ispisaÄ‡e se na ekran tek kada pozovemo z (tj. evaluiraÄ‡e se funkcija). Ovaj koncept je poznat iz FP, vrlo je koristan za keÅ¡iranje vrijednosti.","title":"Uvod u Scalu","url":"/scala/basics.html"},{"text":"","title":"Untitled","url":"/search/results.html"},{"text":"Klase Recimo da imamo zadatak da napravimo program za praÄ‡enje uÄenika u razredu. Za svakog uÄenika moramo unijeti ime, prezime i prosjeÄnu ocjenu. Trebamo ispisati sve ove podatke i na kraju naÄ‡i prosjek ocjena u razredu. Kako bismo ovo uradili sa do sada nauÄenim konceptima? Imena moÅ¾emo staviti npr. u niz String[] imena. Prezimena moÅ¾emo staviti npr. u niz String[] prezimena. Ocjene Ä‡emo staviti npr. u niz double[] prosjeci. String[] imena;\nString[] prezimena;\ndouble[] prosjeci;\n\ndouble zbirProsjeka = 0;\nfor(int i = 0; i < imena.length; i ++) {\n    System.out.print(\"UÄenik: \" + prezimena[i] + \" \" + imena[i]);\n    System.out.println(\", prosjek: \" + prosjeci[i]);\n    zbirProsjeka += prosjeci[i];\n}\ndouble prosjekRazreda = zbirProsjeka / imena.length;\nSystem.out.println(\"Ukupan prosjek razreda: \" + prosjekRazreda);\n Iako ovaj kod radi kako treba, nekako se ne osjeÄ‡amo dobro zbog njega... Indeksi prÅ¡te na sve strane, Å¡ta ako je jedan od nizova kraÄ‡i itd? TakoÄ‘er, ovi nizovi nam uopÄ‡e ne govore da su dio jedne cjeline. Neko ko Äita ovaj kod mora se dobro zapitati Å¡ta oni predstavljaju. To je moÅ¾da lahko na ovom (namjerno) malom primjeru, ali u projektima s milionima linija koda, niko nema vremena da \"razbija glavu\"... :) Ovo je jedan od razloga zaÅ¡to se uvodi apstrakcija klase. Klasa je recept za pravljenje objekta. KaÅ¾e se joÅ¡ i da je objekat instanca klase. Objekat je obiÄno skup primitivnih varijabli i drugih objekata. Dakle, koristi se za logiÄko grupisanje vrijednosti. U prethodnom primjeru trebali bismo grupisati ime, prezime i prosjek. Ova nova apstrakcija tj. klasa bi se zvala Ucenik. To bi izgledalo ovako: class Ucenik {\n    String ime;\n    String prezime;\n    double prosjek;\n}\n Kreiranje objekta Da bismo kreirali novi objekat klase Ucenik, koristimo operator new: Ucenik ucenik = new Ucenik();\n Ovaj operator naziva se konstruktor. Konstruktor je specijalna funkcija koja kreira novi objekat i vrati nam referencu na njega. Kompajler nam automatski kreira konstruktor za nas, kasnije Ä‡emo vidjeti kako sami moÅ¾emo definisati konstruktor(e). Polja klase Vrijednosti unutar klase nazivaju se polja klase/atributi (en. fields, properties), u ovom sluÄaju to su ime, prezime i prosjek. PoÅ¡to im nismo dodijelili nikakve poÄetne vrijednosti, Java Ä‡e ih postaviti na defaultne vrijednosti: referentne na null brojevne primitivne na 0 boolean primitivne na false Dakle, u ovom trenutku, ime ima vrijednost null, prezime ima vrijednost null, prosjek vrijednost 0. Idemo im dati neke smislene vrijednosti: ucenik.ime = \"Mujo\";\nucenik.prezime = \"MujanoviÄ‡\";\nucenik.prosjek = 4.3D;\n Odabir polja se piÅ¡e navoÄ‘enjem reference, pa taÄka, a zatim naziv polja. Dok nismo zaboravili, prethodni primjer sada izgleda puno bolje i razumljivije: Ucenik[] ucenici;\ndouble zbirProsjeka = 0;\nfor(Ucenik u : ucenici) {\n    System.out.print(\"UÄenik: \" + u.prezime + \" \" + u.ime);\n    System.out.println(\", prosjek: \" + u.prosjek);\n    zbirProsjeka += u.prosjek;\n}\ndouble prosjekRazreda = zbirProsjeka / ucenici.length;\nSystem.out.println(\"Ukupan prosjek razreda: \" + prosjekRazreda);","title":"Klase","url":"/java/classes.html"},{"text":"Instalacija Jave Ako vam je baÅ¡ mrsko instalirati Javu, postoje i online alternative: JDoodle JShell Zgodne su za probavanje i igranje sa Javom. PreporuÄujem da instalirate Javu 21 (ili noviju verziju). Samo downloadujte i raspakujte zip npr. u C:\\Java. IduÄ‡i korak je dodavanje PATH varijable. Instalacija Jave 8 je malo komplikovanija, ali je dostupna i za 32-bitne i 64-bitne raÄunare. Naravno, moÅ¾ete instalirati viÅ¡e verzija Jave, ali samo jednu moÅ¾ete dodati u PATH! Kada se otvori stranica sa prethodne slike kliknite na dugme download JDK. JDK (Java Development Kit) su alati za razvijanje Java programa: kompajler, debager itd. JDK sadrÅ¾i JRE (Java Runtime Environment) koji sluÅ¾i za pokretanje Java programa (JVM, Java API klase itd). Na sljedeÄ‡oj slici kliknite na \"jdk-8u131-windows-x64.exe\". To je instalacija za 64-bitni Windows. Ako sluÄajno imate 32-bitni Windows (vrlo malo vjerovatno) onda skinite tu verziju... PreporuÄujem da Javu instalirate u folder pod nazivom C:\\Java. Ovo ne morate raditi ali je korisno kada vam treba viÅ¡e verzija Jave. TakoÄ‘er, neki programi na Windowsu imaju problema kada putanja sadrÅ¾i razmak, zato neÄ‡emo instalirati u Program Files... Napomena: Ne trebate instalirati i JRE! Kada vam doÄ‘e prozor za JRE kliknite Cancel! (iksiÄ‡). Upravo sam vam uÅ¡tedio 100-tinjak megabajta, nema na Äemu... :D Dakle, kada se zavrÅ¡i download, otvorite instalaciju i kliknite Next. Zatim kliknite dugme \"Change...\" i prepravite putanju foldera na C:\\Java\\jdk1.8.0_131. JRE Ä‡e veÄ‡ biti instaliran zajedno sa JDK! Tako da nam ne treba joÅ¡ jedna instalacija... Dodavanje PATH varijabli Dio koji slijedi vezan je viÅ¡e za sam rad operativnog sistema (Windows u naÅ¡em sluÄaju) nego za Javu. Otvorite Computer Properties na Windowsu (desni klik na My Computer -> Properties). OtvoriÄ‡e vam se sljedeÄ‡i prozor: Kliknite na Advanced System Settings. DobiÄ‡ete sljedeÄ‡i prozor: Otvorite Advanced tab i kliknite Environment Variables.... Dodajte 3 sistemske varijable u donji prozor (u System Variables): Naziv varijable Vrijednost JAVA_HOME C:\\Java\\jdk1.8.0_131 JDK_HOME %JAVA_HOME% JRE_HOME %JAVA_HOME%\\jre Glavno, otvorite PATH varijablu i dodajte ;%JAVA_HOME%\\bin na kraj. Nemojte zaboravit taÄkazarez kopirati! :D Bez navodnika, naravno! Kliknite Ok, Ok... To je to! UspjeÅ¡no ste instalirali Javu! :) Stanje bi trebalo biti otprilike ovako: Provjera instalacije Da bi provjerili jesmo li uspjeÅ¡no obavili zadatak, otvoriÄ‡emo Command Prompt (kod LinuxaÅ¡a se rekne Shell). Otvorite Start, ukucajte cmd i kliknite Enter. Ukucajte java -version. Ako dobijete poruku 'java' is not recognized as an internal or external command, operable program or batch file. neÅ¡to nije uredu, provjerite sve korake sekcije \"Dodavanje PATH varijabli\" ponovo! Ako dobijete neÅ¡to sliÄno sljedeÄ‡oj slici, sve je OK:","title":"Instalacija Jave","url":"/java/installation.html"},{"text":"Osnove Jave JShell Da bi se igrali sa JShellom morate imati instaliranu Javu verzije 9 ili viÅ¡e. Ispratite sekciju za instalaciju. KoristiÄ‡emo JShell program za upoznavanje i igranje s Java jezikom. Otvorite konzolu (bez ikakvog straha! :D), ukucajte jshell i udarite Enter. DobiÄ‡ete tzv. interaktivni shell u kojem moÅ¾ete kucati Javu. Zovu ga joÅ¡ i REPL (Read Evaluate Print Loop), jer dobija unos od nas, evaluira ga, isprinta neki odgovor, i ponavlja ukrug. Izrazi i operatori Za poÄetak, JShell moÅ¾emo koristiti kao primitivni kalkulator. Tako Ä‡emo steÄ‡i osjeÄ‡aj kako se ponaÅ¡aju brojevi u Javi, i usput objasniti neke osnovne koncepte i pojmove. Ako ukucamo u REPL broj 5 i pritisnemo Enter, vidjeÄ‡emo sljedeÄ‡e: jshell> 5\n$1 ==> 5\n REPL je razumio i odgovorio nam da je to vrijednost 5. U programiranju se kaÅ¾e da je broj izraz. Izraz u programiranju ima isto znaÄenje kao i u matematici. Dakle, misli se na neÅ¡to Å¡to ima vrijednost. NeÅ¡to Å¡to moÅ¾emo prikazati, s Äim moÅ¾emo baratati. Ako se opet prisjetimo (dosadne) matematike, sjetiÄ‡emo se da se simboli +, -, *, itd. nazivaju operatori. PoÅ¡to smo rekli da je REPL kao kalkulator, da vidimo Å¡ta sve moÅ¾emo uraditi: jshell> 2 + 2\n$2 ==> 4\njshell> 2 - 5\n$3 ==> -3\njshell> 7 * 3\n$4 ==> 21\njshell> 9 / 4\n$5 ==> 2\n Izgleda da dijeljenje ne radi kako treba... NaÅ¡li smo greÅ¡ku! :D Ali, nije tako. Java podrazumijeva da Å¾elimo podijeliti dva cijela broja! Ako se sjetimo osnovne Å¡kole, 5 / 2 je ustvari 2 cijelih i ostatak 1. :) Dakle, kada dijelimo dva cijela broja, ustvari radimo \"cjelobrojno dijeljenje\". TakoÄ‘er, moÅ¾emo dobiti i ostatak od dijeljenja, pomoÄ‡u operatora %. Npr. 5 % 2 je 1. Kada Å¾elimo koristiti realne brojeve (sa zarezom), piÅ¡emo taÄku nakon broja. TaÄka se koristi umjesto zareza, jer se zarez koristi za neke druge stvari. Uglavnom, da vidimo kako rade realni brojevi (en. floating point): jshell> 3.0 + 5.1\n$6 ==> 8.1\njshell> 7.3 - 2.9\n$7 ==> 4.4\njshell> 5.5 * -2.0\n$8 ==> -11.0\njshell> 9.0 / 4.0\n$9 ==> 2.25\n Sada se sve Äini onako kako treba. :) Redoslijed operacija (en. precedence) radi oÄekivano. Npr. mnoÅ¾enje se radi prije sabiranja. Ako Å¾elimo baÅ¡, baÅ¡, biti sigurni da Ä‡e program raditi kako treba, moÅ¾emo koristiti zagrade. jshell> 2 + 2 * 2\n$10 ==> 6\njshell> (2 + 2) * 2\n$11 ==> 8\n Varijable Primijetite Å¡ta REPL ispisuje kao odgovor, poslije svake unesene linije: $1 ==> 5. Ako ukucamo $1 u REPL vidjeÄ‡emo sljedeÄ‡e: jshell> $1\n$1 ==> 5\n Dakle, REPL nam kaÅ¾e da je vrijednost varijable $1 jednaka 5. Izraz 5 je spremljen u varijablu $1, koju moÅ¾emo koristiti umjesto broja 5. Å ta je to varijabla? Zamislite da imate kutije raznih oblika i dimenzija. Varijabla je baÅ¡ kao kutija sa natpisom koji vi Å¾elite. Npr. kutija u kojoj Äuvamo neki broj. KreiraÄ‡emo novu varijablu pod nazivom brojJabuka, za Äuvanje integera (en. \"integer\" je cijeli broj). Ovo int je tip varijable (veliÄina i oblik kutije)! Kasnije Ä‡emo govoriti malo detaljnije o tipovima. jshell> int brojJabuka;\nbrojJabuka ==> 0\ncreated variable brojJabuka : int\n PoÅ¡to nismo dali vrijednost naÅ¡oj varijabli, Java nam pomaÅ¾e tako Å¡to postavlja brojJabuka na vrijednost 0. ObiÄno je to ono Å¡to Å¾elimo, ali je najbolje postaviti poÄetnu vrijednost eksplicitno, Äim uvodimo novu varijablu. Tako odmah znamo koja joj je poÄetna vrijednost i ne moramo razmiÅ¡ljati o tome... :) To radimo ovako: jshell> int brojJabuka = 0;\nbrojJabuka ==> 0\ncreated variable brojJabuka : int\n Vrlo jednostavno, nakon naziva varijable slijedi znak jednako i vrijednost, ovdje je to 0. Primijetite da ovaj znak jednakosti nije matematiÄka jednakost veÄ‡ operacija dodjele! Tj. kao da kaÅ¾emo \"postavi varijablu brojJabuka na nulu!\". Varijablu moÅ¾emo izmijeniti, tj. postaviti na novu vrijednost: jshell> brojJabuka = 5;\nbrojJabuka ==> 5\nassigned to brojJabuka : int\n Sada je vrijednost promijenjena na 5. Nakon ove linije, gdje god koristimo brojJabuka to je kao da napiÅ¡emo 5. TakoÄ‘er, moÅ¾emo iskoristiti prethodnu vrijednost varijable da bismo dobili novu: jshell> brojJabuka = brojJabuka + 1;\nbrojJabuka ==> 6\njshell> brojJabuka += 1;\n$23 ==> 7\n U izrazu brojJabuka + 1, vrijednost brojJabuka odnosi se na zadnju vrijednost varijable, dakle vrijednost prije ove linije, tj. 5. Postoji i skraÄ‡ena verzija za ovo, prikazana na liniji 3, s operatorom +=. TakoÄ‘er imaju skraÄ‡ene verzije i za oduzimanje, mnoÅ¾enje, dijeljenje i modulo: -=, *=, /=, %= respektivno. Ovo \"respektivno\" je fancy izraz za \"u navedenom redoslijedu\". :D Nazivi varijabli Nazivi varijabli i tipova (en. identifiers) ne mogu imati razmake u sebi, ne mogu biti nijedna od rezervisanih rijeÄi kao Å¡to je class, int. Ne mogu biti neki rezervisani znakovi, kao npr. ,, & itd. Ne mogu poÄinjati brojem. Primjeri nevalidnih naziva varijabli (isprobajte u JShellu): int my variable = 5 int int = 5 int , = 5 int 5something = 5 Primjeri validnih naziva varijabli: int _abc = 5 int $xyz = 5 int Z = 5 int t$df_x = 5 Mogu se koristiti simboli _ i $ ali ih treba izbjegavati, pogotovo kao prvo slovo u nazivu varijable! PreporuÄeno je da varijable poÄinju malim slovom, da su camelCase (svaka iduÄ‡a rijeÄ poÄinje velikim slovom), npr. myVariable. Konstante (varijable koje se ne mogu mijenjati) se piÅ¡u velikim slovima i rijeÄi su razdvojene donjom crticom, npr. MY_CONST.","title":"Osnove Jave","url":"/java/basics.html"},{"text":"While petlja Kada Å¾elimo ponavljati izvrÅ¡iti neki dio koda viÅ¡e puta, najjednostavniji naÄin je copy-paste. Kopiramo ga n-puta i zavrÅ¡eno! :D MeÄ‘utim, ovo nije fleksibilno kada kasnije Å¾elimo da izmijenimo taj djeliÄ‡ koda. Tada moramo izmijeniti sve linije... :/ Zato postoje specijalne naredbe za ponavljanje: while, do-while i for. Zovu se joÅ¡ i \"petlje\", jer se vrlo lahko zapetljati u njima. U sljedeÄ‡em primjeru Å¾elimo izvrÅ¡avati kod sve dok je neki uslov ispunjen (en. while je \"dok\"). int i = 0;\nwhile(i < 10) {\n    System.out.println(\"Cifra i je: \" + i);\n    i = i + 1;\n}\n Naravno, unutar tog bloka uslov se mora mijenjati, inaÄe se program neÄ‡e nikad zaustaviti. To se naziva beskonaÄna petlja i obiÄno nije poÅ¾eljna... :) Uslov se ispituje u svakoj iteraciji petlje. Dakle, svaki put kada se doÄ‘e do linije 5 uslov Ä‡e se ponovo ispitati. Ako uslov nije zadovoljen, petlja se zaustavlja i program se nastavlja izvrÅ¡avati na liniji 6.","title":"While petlja","url":"/java/while.html"},{"text":"Hello World! Vjerovatno vam je do sada dodijao JShell i kucanje u konzoli... :D Sada Ä‡emo vidjeti kako se ustvari pokreÄ‡u Java programi. Sastoji se iz 2 dijela: kompajliranje i pokretanje (en. run). Napomena: ovaj dio nije obavezan, ali pomaÅ¾e za razumijevanje procesa. MoÅ¾ete preskoÄiti na sekciju Implementacija ako Å¾elite. Kompajler (en. compiler) je program koji provjerava sintaksu naÅ¡eg programa, da li se poklapaju tipovi itd. te nam prijavljuje greÅ¡ke ako ih pronaÄ‘e. I to sve prije nego smo i pokrenuli naÅ¡ program! Predobro! :D Tako smo sigurni da se bar neke greÅ¡ke neÄ‡e pojaviti u programu. Javin kompajler se zove javac (skraÄ‡eno od Java compiler). Ulaz u kompajler je izvorni tekst programa (en. source code) koji smo napisali (obiÄni tekstualni fajlovi s nastavkom .java ), a izlaz su fajlovi koji sadrÅ¾e izvrÅ¡ni kod, koji se moÅ¾e pokrenuti nekako, izvrÅ¡iti (to su .class fajlovi). IduÄ‡i korak je pokretanje programa. Java programi se sastoje od bytecode naredbi (kod nezavisan od procesora i operativnog sistema), koje su vrlo sliÄne maÅ¡inskom kodu (specifiÄnom za svaki procesor). Izlaz iz kompajlera, .class fajlovi sadrÅ¾e te bytecode naredbe, i njih izvrÅ¡ava tzv. JVM (Java Virtuelna MaÅ¡ina). JVM je ustvari java program. Implementacija Da vidimo napokon kako izgleda obavezni \"Hello World\" primjer: class HelloWorldApp {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n    }\n}\n Kada se pokrene prethodno prikazani program dobiÄ‡emo sljedeÄ‡i rezultat u konzoli: Hello World!\n Kompajliranje i pokretanje programa SadrÅ¾aj programa saÄuvajte u fajl HelloWorldApp.java. Primijetite da se mora zvati isto kao i klasa, s nastavkom .java! Kod mene se ovo sve nalazi u folderu C:\\programiranje. Kucamo sljedeÄ‡e: C:\\programiranje> javac HelloWorldApp.java\nC:\\programiranje> java HelloWorldApp\nHello World!\n To je to, sada moÅ¾emo nastaviti dalje. Svaki primjer koji budemo radili moÅ¾ete isprobati, nemojte mi slijepo vjerovati na rijeÄ da fercera. :) Komentari Komentari su tekst koji ne utiÄe na rezultat programa. Koriste se samo radi objaÅ¡njavanja koda, nekom drugom ili nama kad budemo Äitali kasnije. Prva vrsta komentara se piÅ¡e sa 2 kose crte // (en. slash) i vrijedi do kraja linije. Druga vrsta je viÅ¡elinijska (en. multiline) i poÄinje s /* a zavrÅ¡ava s */. Npr: // komentar1\n    \n/*\n    * komentar2\n    */\n\nclass HelloWorldApp {\n    ...","title":"Hello World!","url":"/java/hello-world.html"},{"text":"For petlja Java ima i tzv. for petlje. To su haman-ha while petlje s finijom sintaksom. SljedeÄ‡i primjer radi isto kao i prethodni sa while petljom. for (int i = 0; i < 10; i = i + 1) {\n    System.out.println(\"Cifra i je: \" + i);\n}\n UopÄ‡ena sintaksa for petlje je sljedeÄ‡a: for(inicijalizacije; uslov; koraci). Dijelovi for petlje su razdvojeni taÄkazarezom. Umjesto da deklariÅ¡emo varijable prije petlje, zgodno je deklarisati ih u sklopu petlje, jer nam poslije petlje one ne trebaju. Za to nam sluÅ¾i dio inicijalizacije. Dio uslov je isti kao i kod while petlje. Dio koraci dolazi na kraju petlje, isto kao linija 4 u naÅ¡oj while petlji. Koraci obiÄno utiÄu na uslov za izlaz iz petlje.","title":"For petlja","url":"/java/for.html"},{"text":"Nizovi Kada trebamo zapamtiti viÅ¡e vrijednosti istog tipa, to radimo pomoÄ‡u niza (en. array). Tip niza se piÅ¡e kao tip[]. Ovo \"tip\" moÅ¾e biti int, String ili bilo Å¡ta drugo. Uglate zagrade kaÅ¾u da se radi o nizu, a ne \"obiÄnom\" tipu. Kada kreiramo niz, kaÅ¾emo new tip[velicina], gdje je velicina neki broj, mora biti int. DuÅ¾ina niza je fiksna, ne moÅ¾e se promijeniti! Kada pristupamo elementu niza, to radimo preko indeksa, tj. rednog broja u nizu. Prvi element ima indeks 0, drugi ima indeks 1 itd. Npr. da bi izmijenili prvi element piÅ¡emo niz[0] = 9;. Ovdje nam odmah naumpadaju petlje koje smo nauÄili, while i for koje su vrlo korisne pri radu s nizovima. Ako Å¾elimo npr. spremiti ocjene studenta, za to moÅ¾emo koristiti niz. Recimo da student ima 12 predmeta. int[] ocjene; // nije joÅ¡ inicijaliziran, ne bi ga trebali koristiti!\nocjene = new int[12]; // niz od 12 nula (po defaultu se popuni nulama)\n\nocjene[0] = 9;\n\nfor(int i = 0; i < 12; i++) {\n    System.out.println(ocjene[i]);\n}\n Vidimo da se 12 ponavlja na 2 mjesta, i oznaÄava istu stvar, duÅ¾inu niza. Naravno, to nije dobra praksa, jer ako trebamo promijeniti duÅ¾inu niza, to moramo odraditi na viÅ¡e mjesta. MoÅ¾emo napraviti novu varijablu u koju Ä‡emo spremiti duÅ¾inu niza. Npr. int BR_OCJENA = 12; i onda koristiti nju umjesto literala 12. Ovako je kod puno fleksibilniji. MeÄ‘utim, ne znamo uvijek duÅ¾inu niza unaprijed. Å ta ako pravimo funkciju koja prima niz? Da proslijedimo uvijek i duÅ¾inu niza? To bi bilo vrlo neÄitljivo i dosadno. SreÄ‡om, nizovi u Javi imaju polje (en. property) koje sadrÅ¾i duÅ¾inu niza i zove se length. Kada kaÅ¾emo ocjene.length dobiÄ‡emo duÅ¾inu niza. :) Tako da smo u primjeru mogli/trebali napisati for(int i = 0; i < ocjene.length; i++). Postoji joÅ¡ jedan zgodan naÄin za inicijalizaciju niza. Ako znamo unaprijed Å¡ta niz sadrÅ¾i, moÅ¾emo odmah dodijeliti te vrijednosti nizu. Pritome ne moramo ni navoditi duÅ¾inu niza, jer Ä‡e nam kompajler pomoÄ‡i. Kad smo veÄ‡ kod \"zgoda\", imamo i tzv. \"poboljÅ¡anu for petlju\" (en. enhanced for loop). Zove se joÅ¡ i \"for-each\" petlja. Ona se koristi kada Å¾elimo da proÄ‘emo kroz sve elemente niza. Ako nam treba i indeks onda moramo koristiti obiÄnu for petlju... // array literal\nString[] gradovi = { \"Sarajevo\", \"Tuzla\", \"Mostar\" };\n\n// enhanced for loop\nfor(String grad: gradovi) {\n    System.out.println(grad);\n}\n ViÅ¡edimenzionalni nizovi MoÅ¾emo imati i niz nizova, niz nizova nizova itd. Ne postoji ograniÄenje na dubinu u koju idemo. Nizovi sa 2 ili viÅ¡e dimenzija nazivaju se \"viÅ¡edimenzionalni\" (en. multidimensional). Dvodimenzionalni nizovi se zovu joÅ¡ i \"matrice\" (en. matrix). Matrice se Äesto koriste u igricama i matematiÄkim programima. Npr. kad trebamo predstaviti stanje Å¡ahovske ploÄe i sl. to moÅ¾emo uraditi sa matricom. UgnijeÅ¾deni nizovi ne moraju imati istu duÅ¾inu. Recimo da imamo zgradu sa razliÄitim brojem stanova po spratu. Svaki red predstavlja jedan sprat, i u svakom spratu imamo br. stanara za svaki stan. Trebamo ispisati koliko koji sprat ima ukupno stanara: int[][] brStanaraPoStanovima = { \n    { 1, 2, 3, 4 }, // prvi sprat\n    { 5, 6, 2 }     // drugi sprat\n};\n\nfor (int i = 0; i < brStanaraPoStanovima.length; ++i) {\n    int brStanaraSprata = 0;\n    for(int j = 0; j < brStanaraPoStanovima[i].length; ++j) {\n        brStanaraSprata += brStanaraPoStanovima[i][j];\n    }\n    System.out.println(\"Br. stanara sprata \" + i + \" je: \" + brStanaraSprata);\n}\n Rezultat: Br. stanara sprata 0 je: 10\nBr. stanara sprata 1 je: 13","title":"Nizovi","url":"/java/arrays.html"},{"text":"Tipovi VeÄ‡ina ozbiljnih jezika ima tipove. One koji nemaju slobodno izbjegavajte! ğŸ˜‰ Tip je apstrakcija koju dati p.j. razumije. Npr. kada napiÅ¡emo int broj, ovo \"int\" je tip varijable \"broj\". Tako Ä‡e kompjuter znati, izmeÄ‘u ostalog, koliko memorije da rezerviÅ¡e za tu varijablu. PoÅ¡to smo mu dali tu informaciju, onda nam moÅ¾e i ukazati na greÅ¡ke u programu koji piÅ¡emo. Npr. da ne moÅ¾emo sabirati broj i slovo, kruÅ¡ke i jabuke... TakoÄ‘er nas moÅ¾e i usmjeriti, npr. reÄ‡i nam koje su operacije dostupne nad datim tipom, da ne moramo nagaÄ‘ati. Da vidimo JShell u akciji: jshell> int broj = 6;\nbroj ==> 6\njshell> broj = 4.5;\nError:\nincompatible types: possible lossy conversion from double to int\nbroj = 4.5;\n^-^\n Dakle, Java nam ne da da dodijelimo broj 4.5 varijabli koja je tipa int (cijeli broj). To ima smisla itekako, jer bismo izgubili ovo \"zarez pet\"... :) Ako Å¾elimo da budemo pametniji od Jave, i da na silu \"utrpamo\" 4.5 u int to ide ovako: jshell> broj = (int) 4.5;\nbroj ==> 4\n I Å¡ta smo dobili? Samo cijeli dio... Ali, nekad nam ovo baÅ¡ i treba! Uglavnom, pouka je da trebamo sluÅ¡ati Å¡ta nam Java poruÄuje! To radi za naÅ¡e dobro, nju nije briga ako je rezultat netaÄan, ako je to ono Å¡to Å¾elimo... :D Naravno, imamo joÅ¡ puno toga reÄ‡i o tipovima, tek smo \"zagrebali povrÅ¡inu\"! Npr. kako da grupiÅ¡emo podatke? Kompleksni brojevi, podaci o ljudima, proizvodima itd? O tom Ä‡emo priÄati u poglavlju o klasama. :) Stringovi i karakteri Prije nego nastavimo dalje, moramo objasniti i stringove, jer se vrlo Äesto koriste. String (iz en. nit, kanafa) koristi se za predstavljanje teksta, tj. niza karaktera. Karakter (en. character je simbol) oznaÄava jedan simbol, bio to broj, slovo ili neki simbol, emoji... Stringovi se piÅ¡u s dvostrukim navodnicima: jshell> \"Poyy sviete!\"\n$1 ==> \"Poyy sviete!\"\n Stringovi se tretiraju specijalno u Javi, pa imamo i operator \"sabiranja\" nad njima. Npr. moÅ¾emo \"sabrati\" 2 stringa, string s brojem i sl: jshell> \"Ime\" + \"Prezime\"\n$2 ==> \"ImePrezime\"\njshell> \"x je \" + 5\n$3 ==> \"x je 5\"\njshell> \"x je \" + 5 + \", i kad se pomnoÅ¾i s \" + 3 + \" daje \" + (5*3)\n$4 ==> \"x je 5, i kad se pomnoÅ¾i s 3 daje 15\"\njshell> \"strin\" + 'g'\n$5 ==> \"string\"\njshell> String s = \"ABC\"\ns ==> \"ABC\"\n Ovo sabiranje se naziva konkatenacija (en. concatenate je nadovezati/spojiti/naÅ¡tiklati). Radi dvosmjerno, moÅ¾emo sabrati i broj sa stringom, npr. 5 + \"hepek.abc\". String se piÅ¡e s velikim poÄetnim slovom! String u pozadini koristi charactere. Kao Å¡to smo veÄ‡ rekli, char je samo jedan karakter. PiÅ¡e se s jednostrukim navodnicima: jshell> 'a'\n$9 ==> 'a'\n\njshell> ''\nError:\nempty character literal\n''\n^\n        'ab'\nError:\nunclosed character literal\n'ab'\n^\n\njshell> char slovoA = 'A'\nslovoA ==> 'A'\n Dakle, karakter ne moÅ¾e biti prazan, niti moÅ¾e sadrÅ¾ati viÅ¡e karaktera. Za ove namjene koristi se String! :) VaÅ¾ne napomene: string \"1\" nije isto kao broj 1 karakter '1' nije isto kao broj 1 string \"1\" nije isto kao karakter '1' postoje posebne funkcije za pretvaranje iz jednog tipa u drugi","title":"Tipovi","url":"/java/types.html"},{"text":"Funkcije Prvo malo terminologije. Potprogram (en. subprogram, subroutine, procedure) je dio programa koji moÅ¾emo pozvati po imenu. Java ih zove... khm... metode... :D Ja Ä‡u najÄeÅ¡Ä‡e koristiti termin \"funkcija\" ili \"metoda\", kako kad. Funkcijama se mogu proslijediti argumenti, tj. ulazni podaci koje funkcija moÅ¾e koristiti. Slijedi primjer funkcije za sabiranje dva cijela broja: int suma(int a, int b) {\n    return a + b;\n}\n Definicija funkcije ima sljedeÄ‡e dijelove: tip vrijednosti koju vraÄ‡a funkcija. Kod nas je to int, jer je rezultat sabiranja dva inta takoÄ‘er int. naziv funkcije, kod nas je to \"suma\" lista parametara u zagradama, ovdje su to brojevi: int a, int b. Ako nema parametara onda idu samo zagrade, npr. mojaFunkcija() tijelo funkcije u vitiÄastim zagradama kljuÄna rijeÄ return i rezultat funkcije Da vidimo u JShellu kako da deklariÅ¡emo i pozovemo prethodnu funkciju: jshell> int suma(int a, int b) {\n    return a + b;\n}\ncreated method suma(int,int)\njshell> suma(1, 4)\n$6 ==> 5\n Funkcija se poziva navoÄ‘enjem njenog imena, i argumenata unutar zagrada. Npr. suma(1, 4). PoÅ¡to poziv funkcije vraÄ‡a vrijednost int, moÅ¾emo je spasiti u varijablu, npr. int rezultat = suma(1, 4). Dakle, i poziv funkcije je izraz! ÄŒim ga moÅ¾emo dodijeliti varijabli. :)","title":"Funkcije","url":"/java/functions.html"},{"text":"Naredbe Naredbe (en. statements) su kao reÄenice u govornom jeziku, i obiÄno su u imperativnom obliku, kao da se obraÄ‡amo kompjuteru: uradi ovo, izbriÅ¡i ono, upiÅ¡i u fajl itd. Deklaracije varijabli su naredbe, npr. int i = 5;, moÅ¾e se Äitati kao \"napravi varijablu s imenom 'i' i dodijeli joj vrijednost 5! ODMAH!\". Iako joÅ¡ nismo objasnili funkcije, neke od njih su takoÄ‘er naredbe, npr: jshell> System.out.println(\"Hello!\")\nHello!\n Vrlo duga naredba System.out.println je funkcija za printanje u konzolu. Do sada je JShell to automatski radio za nas, ispisivao vrijednost zadnjeg izraza, u svom nekom predefinisanom formatu... Ovako mi moÅ¾emo ispisati Å¡ta god Å¾elimo. Primijetite da ispisani String nema navodnika! Navodnici se samo koriste za pisanje stringova!!! Nisu ukljuÄeni u samu vrijednost stringa. Isto je i sa karakterima. Da vidimo joÅ¡ par primjera: jshell> System.out.println(\"x je \" + 5);\nx je 5\n\njshell> String rezultat = \"x je \" + 5;\nrezultat ==> \"x je 5\"\njshell> System.out.println(rezultat);\nx je 5\n Dakle, moÅ¾emo proslijediti string direktno, ili varijablu koja je string, svejedno. ğŸ™‚ Kraj naredbe se oznaÄava s ; (taÄkazarez, en. semicolon).","title":"Naredbe","url":"/java/statements.html"},{"text":"Uslovno grananje Kompjuteri obiÄno izvrÅ¡avaju naredbe jednu nakon druge tj. sekvencijalno. MeÄ‘utim, potrebne su nam i naredbe za uslovno grananje. To jest, kada Å¾elimo izvrÅ¡iti neÅ¡to samo pod datim uslovima. U Javi za ovu svrhu imamo 2 naredbe: if i switch. If naredba Grananje pomoÄ‡u if naredbe je vrlo jednostavno. Ako je uslov ispunjen onda Ä‡e se taj dio koda izvrÅ¡iti. U suprotnom program nastavlja dalje. Ovo \"uslov ispunjen\" moÅ¾e biti DA ili NE, tj. ISTINA (en. true) ili NEISTINA (en. false). Ovaj tip podatka se naziva Boolean po matematiÄaru George Boole-u. Ako se sjeÄ‡ate logike iz matematike, tablica istine, \"I\", \"ILI\", \"NE\" i ostalih, TO JE TO! :D LogiÄka operacija \"I\" (en. and) se u Javi piÅ¡e sa && LogiÄka operacija \"ILI\" (en. or) se u Javi piÅ¡e sa || LogiÄka operacija \"NE\" (en. negate, not) se u Javi piÅ¡e sa !, i piÅ¡e se prije uslova koji negira, npr. !small. Primjer: double temperatura = -3;\nboolean uslovHladno = temperatura < 5;\nif (uslovHladno) {  // moÅ¾e i \"if(temperatura < 5)\"\n    System.out.println(\"Obuci se, studeno je pravo!\");\n}\nSystem.out.println(\"Temperatura je: \" + temperatura);\n Navedeni primjer ispisaÄ‡e sljedeÄ‡e: Obuci se, studeno je pravo!\nTemperatura je: -3\n Ako izmijenimo temperaturu na 20, vidjeÄ‡emo da se prvi println neÄ‡e izvrÅ¡iti, jer uslov nije ispunjen: Temperatura je: 20\n Da vidimo joÅ¡ jedan primjer: double temperatura = 21.33;\nboolean uslovToplo = temperatura > 25;\nif (uslovToplo) // moÅ¾e i \"if(temperatura > 25)\"\n    System.out.println(\"Toplo je\");\nelse\n    System.out.println(\"Nije toplo\");\n Prethodni kod Ä‡e ispisati \"Nije toplo\", jer uslov uslovToplo nije ispunjen, tj. izraz 21.33 > 25 je false. Ovo if else se tretira kao jedna naredba! Ako Å¾elimo da izvrÅ¡imo viÅ¡e od jedne naredbe u if ili else bloku, samo ih okruÅ¾imo zagradama: if (uslov) { naredbe1... } else { naredbe2... }. Nakon linije 6 program nastavlja normalno sa svojim izvrÅ¡enjem. MoÅ¾emo imati i viÅ¡e uslova u jednoj naredbi, tj. niz if-elseif-elseif-...-else. Ovi uslovi bi trebali biti meÄ‘usobno iskljuÄivi tj. smisleni. Ako napiÅ¡ete if (broj>5) { } else if (broj>7) { } to nema puno smisla jer ako broj nije veÄ‡i od 5, ne moÅ¾e biti veÄ‡i od 7, nema Å¡ansone. :D Ako jeste veÄ‡i od 5, biÄ‡e izvrÅ¡en prvi blok, ali drugi blok koda NIKAD NEÄ†E BITI IZVRÅ EN! Ako postoji grana else, ona Ä‡e biti izvrÅ¡ena ako nijedan uslov nije ispunjen. Ako ne postoji else i nijedan uslov nije ispunjen, niÅ¡ta neÄ‡e biti izvrÅ¡eno od te cijele if naredbe. Switch naredba Grananje pomoÄ‡u switch naredbe moÅ¾e uÄiniti kod dosta preglednijim. Ova naredba se koristi umjesto mnoÅ¡tva if-else grana, od koje svaka grana provjerava je li varijabla jednaka nekoj vrijednosti. U Javi moÅ¾ete \"switchati\" cijele brojeve, karaktere, stringove i enumeracije. int i = 5;\nswitch (i) {\n    case 3:\n        System.out.println(\"Tri\");\n        break;\n    case 5:\n        System.out.println(\"Pet\");\n        break;\n    default:\n        System.out.println(\"Ne znam...\");\n        break;\n}\n Na liniji 2 ispituje se Äemu je jednaka vrijednost varijable i, redom odozgo naravno. Prvi sluÄaj (en. case) koji bude ispunjen Ä‡e biti izvrÅ¡en. Ako je vrijednost varijable i broj 5, ispisaÄ‡e se na ekran \"Pet\". ÄŒesto ne znamo koliko ima moguÄ‡ih sluÄajeva, pa onda trebamo odluÄiti Å¡ta da uradimo po tom pitanju. Za to nam sluÅ¾i kljuÄna rijeÄ default. To je ustvari ona else grana u if naredbi! ;)","title":"Uslovno grananje","url":"/java/branching.html"},{"text":"Opseg Svaka varijabla/funkcija/klasa u Javi ima svoj opseg (en. scope). Scope je dio programa u kom je ta varijabla vidljiva tj. moÅ¾e se tu koristiti. Scope-ovi mogu biti ugnijeÅ¾deni. UnutraÅ¡nji scope moÅ¾e vidjeti tj. koristiti varijable iz vanjskog scope. UnutraÅ¡nji scope moÅ¾e definisati novu varijablu koja se zove isto kao varijabla u vanjskom scope! Postoje dva najvaÅ¾nija scope-a a to su: scope klase i scope metode. Scope metode je ugnijeÅ¾den u scope klase. Npr. polja klase se mogu koristiti u metodama, ali varijable definisane u metodi se ne mogu koristiti u klasi: class Abc {\n    int x = 5;\n    // int z = y + 2; // ovo nije dozvoljeno\n\n    void bla() {\n        int y = x + 1;\n    }\n    \n    void meh() {\n        int y = x + 3;\n    }\n}\n Na liniji 3. vidimo primjer nedozvoljene operacije. Ako se pitate zaÅ¡to: Polja objekta se inicijalizuju Äim se pozove konstruktor te klase. Metode se pozivaju na zahtjev tj. ruÄno, on-demand. Zato nam Java ne dozvoljava tu operaciju. TakoÄ‘er, kompajler ne zna na koje y mislimo, da li ono iz bla() ili iz meh()... :) Primijetite i to da varijabla y iz bla() nema nikakve veze s varijablom y iz meh()!!! To su dva skroz nezavisna bloka, svaki ima svoj scope. Neki primjeri nedozvoljenog definisanja varijabli su dati u metodi ne(). OtkomentariÅ¡ite liniju po liniju da vidite Å¡ta Ä‡e vam kompajler reÄ‡i. U metodi da() dati su neki primjeri dozvoljenog koriÅ¡tenja istoimenih varijabli. static void ne() {\n    int x = 1;\n    {\n        // int x = 1; // nope\n    }\n    \n    {\n        int y = 1;\n    }\n    // y++; // ne moÅ¾e se koristiti izvan bloka! (isto je i za if, for, while, switch)\n    \n    // for(int x = 1; x < 5; x++) { }  // x vec definisano na pocetku metode\n    \n    // while(true) { int x = 1; }      // x vec definisano na pocetku metode\n    \n    for(int i = 1; i < 5; i++) {\n        // for(int i = 1; i < 5; i++) {  } // i vec definisano u vanjskoj petlji\n    }  \n}\n\nint duzina;\nstatic void da() {\n\n    // zasjenjivanje polja (shadowing)\n    // poÅ¡to metoda ima svoj scope, \n    // dozvoljeno joj je uvesti novu varijablu istog imena kao polje klase\n    int duzina = 5;\n    \n    // razliÄiti blokovi\n    {\n        String str = \"abc\";\n    }\n    {\n        String str = \"abc\"; // yep, nije na istom NIVOU\n    }\n    \n    // razliÄite petlje/blokovi\n    for(int x = 1; x < 5; x++) { }\n    for(int x = 1; x < 5; x++) { } // fercera\n    \n}","title":"Opseg","url":"/java/scope.html"},{"text":"Tipovi, opet Rekli smo da Ä‡emo nastaviti malo detaljnije o tipovima. Java ima 2 vrste tipova: primitivne i referentne. Primitivni tipovi Primitivnih tipova ima 8 i to su boolean, char, int, long, short, byte, double i float. PiÅ¡u se malim slovima. Ne moÅ¾emo definisati nove primitivne tipove u Javi! Primitivni tipovi predstavljaju \"sirove podatke\", veÄ‡ina referentnih tipova ih koristi u pozadini. Referentni tipovi U referentne tipove ubrajaju se svi tipovi koji nisu primitivni. Ove tipove moÅ¾emo definisati i mi sami. Konvencija je da se piÅ¡u velikim poÄetnim slovom. VeÄ‡ smo vidjeli par primjera ovog tipa: String i nizovi. U nastavku Ä‡emo vidjeti kako da definiÅ¡emo klase, koje spadaju u referentne tipove. Reference Varijable koje imaju referentni tip nazivaju se reference. VRLO VAÅ½NO: Svaka referenca moÅ¾e imati vrijednost null!!! Primitivne varijable nikada ne mogu biti null. Vrijednost null je specijalna vrijednost. Ona oznaÄava da je varijabla \"prazna\", neupotrebljiva.","title":"Tipovi, opet","url":"/java/types2.html"},{"text":"Maths Nothing here yet.","title":"Maths","url":"/en/maths/index.html"},{"text":"These are my ramblings about programming.","title":"Programming","url":"/en/programming/index.html"},{"text":"Welcome!","title":"Home Page","url":"/en/index.html"},{"text":"FlowRun Kompjuteri izvrÅ¡avaju naredbe jednu po jednu, redom. Naredbe su logiÄki grupisane u programe. Program sadrÅ¾i naredbe koje kompjuter treba izvrÅ¡iti. Program se moÅ¾e predstaviti vizuelno pomoÄ‡u dijagrama toka (engl. flowchart). KoristiÄ‡emo ugraÄ‘eni editor, koji moÅ¾e i pokrenuti program koji napravimo. Ako Å¾elite da saÄuvate svoje programe koje napravite, moÅ¾ete se registrovati na flowrun.io. Tu moÅ¾ete vidjeti i neke programe koje su napravili drugi korisnici, kliknite ovdje. Tutorijali: Osnove Varijable If naredba While petlja Do While petlja For petlja UgraÄ‘ene funkcije Definisanje funkcije Povratna vrijednost funkcije Rekurzivne funkcije","title":"FlowRun","url":"/flowrun/index.html"},{"text":"FlowRun Kompjuteri izvrÅ¡avaju naredbe jednu po jednu, redom. Naredbe su logiÄki grupisane u programe. Program sadrÅ¾i naredbe koje kompjuter treba izvrÅ¡iti. Program se moÅ¾e predstaviti vizuelno pomoÄ‡u dijagrama toka (engl. flowchart). KoristiÄ‡emo ugraÄ‘eni editor, koji moÅ¾e i pokrenuti program koji napravimo. Ako Å¾elite da saÄuvate svoje programe koje napravite, moÅ¾ete se registrovati na flowrun.io. Tu moÅ¾ete vidjeti i neke programe koje su napravili drugi korisnici, kliknite ovdje. Tutorijali: Osnove Varijable If naredba While petlja Do While petlja For petlja UgraÄ‘ene funkcije Definisanje funkcije Povratna vrijednost funkcije Rekurzivne funkcije","title":"FlowRun","url":"/flowrun/index-2.html"},{"text":"Matematika Matematika je jedan od najomraÅ¾enijih predmeta kod veÄ‡ine uÄenika. S pravom, dakako! Zapitajmo se Å¡ta je uzrok tome? Da li je matematika zaista toliko teÅ¡ka, komplikovana? Odgovor je jednostavan, naravno... da jeste. :D Ako ne razumijemo osnovne koncepte kao Å¡to su skupovi i funkcije, kako nastaviti dalje? Å ta profesori rade po tom pitanju? ObiÄno piÅ¡u knjige od po 1000+ stranica i nazivaju ih jednostavnim... Po mom skromnom miÅ¡ljenju, veÄ‡ina koncepata nije dovoljno dobro ili nikako objaÅ¡njena. Npr, meni nikad nisu objaÅ¡njavali Å¡ta znaÄe razni simboli tipa âˆ€\\forallâˆ€, âˆƒ\\existsâˆƒ i â†’\\rightarrowâ†’... To se smatra elementarnim i krivica se prebacuje ili na prethodnog profesora ili pak na mene jer sam glup pa to ne znam. Zar je sramota pitati takva pitanja? HoÄ‡eÅ¡ li ti biti manje profesor ako zastaneÅ¡ 5 minuta i objasniÅ¡ terminologiju? Lema, korolar, teorema, Å¡ta su te stvari??? :D NauÄi me! To ti je pos'o! SadrÅ¾aj: Teorija skupova","title":"Matematika","url":"/maths/index.html"},{"text":"Programiranje SadrÅ¾aj: Filozofija programiranja Programerska terminologija Paradigme programiranja","title":"Programiranje","url":"/programming/index.html"},{"text":"Saketov blog Moje ime je Sakib, bujrum! :) Ovdje Ä‡ete pronaÄ‡i tutorijale za programiranje i joÅ¡ poneÅ¡to. Ako ste totalni poÄetnik, i Å¾elite nauÄiti programirati, preporuÄujem da poÄnete sa dijagramima toka. Dosta je lakÅ¡e poÄeti s vizuelnim programiranjem, jer praÄ‡enjem linija lakÅ¡e je shvatiti kako program radi. Ovi tutorijali vode vas kroz osnovne gradivne dijelove programa. Nakon toga moÅ¾ete nastaviti s Java programskim jezikom. Tu Ä‡ete se upoznati sa jednim vrlo popularnim, traÅ¾enim i plaÄ‡enim programskim jezikom. Vrlo je sliÄan drugim popularnim jezicima kao Å¡to su C#, JavaScript i ostali. Tako da ako se odluÄite i za neki drugi jezik kasnije, neÄ‡e vam biti teÅ¡ko da ga savladate.","title":"PoÄetna stranica","url":"/index.html"},{"text":"Saketov blog Moje ime je Sakib, bujrum! :) Ovdje Ä‡ete pronaÄ‡i tutorijale za programiranje i joÅ¡ poneÅ¡to. Ako ste totalni poÄetnik, i Å¾elite nauÄiti programirati, preporuÄujem da poÄnete sa dijagramima toka. Dosta je lakÅ¡e poÄeti s vizuelnim programiranjem, jer praÄ‡enjem linija lakÅ¡e je shvatiti kako program radi. Ovi tutorijali vode vas kroz osnovne gradivne dijelove programa. Nakon toga moÅ¾ete nastaviti s Java programskim jezikom. Tu Ä‡ete se upoznati sa jednim vrlo popularnim, traÅ¾enim i plaÄ‡enim programskim jezikom. Vrlo je sliÄan drugim popularnim jezicima kao Å¡to su C#, JavaScript i ostali. Tako da ako se odluÄite i za neki drugi jezik kasnije, neÄ‡e vam biti teÅ¡ko da ga savladate.","title":"PoÄetna stranica","url":"/index-2.html"},{"text":"Saketov blog Moje ime je Sakib, bujrum! :) Ovdje Ä‡ete pronaÄ‡i tutorijale za programiranje i joÅ¡ poneÅ¡to. Ako ste totalni poÄetnik, i Å¾elite nauÄiti programirati, preporuÄujem da poÄnete sa dijagramima toka. Dosta je lakÅ¡e poÄeti s vizuelnim programiranjem, jer praÄ‡enjem linija lakÅ¡e je shvatiti kako program radi. Ovi tutorijali vode vas kroz osnovne gradivne dijelove programa. Nakon toga moÅ¾ete nastaviti s Java programskim jezikom. Tu Ä‡ete se upoznati sa jednim vrlo popularnim, traÅ¾enim i plaÄ‡enim programskim jezikom. Vrlo je sliÄan drugim popularnim jezicima kao Å¡to su C#, JavaScript i ostali. Tako da ako se odluÄite i za neki drugi jezik kasnije, neÄ‡e vam biti teÅ¡ko da ga savladate.","title":"PoÄetna stranica","url":"/index-3.html"},{"text":"Scala Scala je programski jezik visokog nivoa. Ime je dobila iz opisnog izraza \"SCAlable LAnguage\". Ubrzo Ä‡emo vidjeti i zaÅ¡to! :D Objedinjuje koncepte iz objektno orijentisanog programiranja (OOP) i funkcionalnog programiranja (FP). PoÅ¡to na raspolaganju imamo cijelu lepezu moguÄ‡nosti, treba znati pametno odabrati pravi skup \"alata\" za dati problem koji rjeÅ¡avamo. Primarna platforma na kojoj se izvrÅ¡ava je Java Virtuelna MaÅ¡ina (JVM), pa se mogu koristiti svi library iz Jave. Scala ima statiÄke tipove, kao npr. C# ili Java, ali ima podrÅ¡ku Äak i za dinamiÄke (Javascript, Ruby) i strukturalne tipove (kao Typescript)! Ovako je npr. podrÅ¾ana interoperabilnost sa Javascriptom, pogledajte ScalaJS projekat. Ima vrlo fleksibilnu i lijepu sintaksu, pa je pogodna i za pisanje DSL-ova (Domain-Specific Language). Postoje brojni library i frameworci za konkurentno i distribuirano programiranje. Neki od tih su Future (u standardnoj library), Akka Actors, Apache Spark, Kafka i dr. Lista tutorijala: Osnove","title":"Scala","url":"/scala/index.html"},{"text":"Java Pretpostavljam da ste preÅ¡li vizuelno programiranje. Ako niste, preporuÄujem da prvo preÄ‘ete taj dio! Dosta vremena Ä‡emo posvetiti objaÅ¡njavanju koncepata i terminologije. Terminologija je vrlo bitna, jer Ä‡ete kasnije lakÅ¡e razgovarati o datim konceptima i brÅ¾e Ä‡ete uÄiti ostale programske jezike, \"povezivati kockice\". Tutorijali: Instalacija Osnove Tipovi Naredbe Hello World! Uslovno grananje While petlja For petlja Funkcije Nizovi Tipovi, opet Klase Opseg","title":"Java","url":"/java/index.html"},{"text":"Java Pretpostavljam da ste preÅ¡li vizuelno programiranje. Ako niste, preporuÄujem da prvo preÄ‘ete taj dio! Dosta vremena Ä‡emo posvetiti objaÅ¡njavanju koncepata i terminologije. Terminologija je vrlo bitna, jer Ä‡ete kasnije lakÅ¡e razgovarati o datim konceptima i brÅ¾e Ä‡ete uÄiti ostale programske jezike, \"povezivati kockice\". Tutorijali: Instalacija Osnove Tipovi Naredbe Hello World! Uslovno grananje While petlja For petlja Funkcije Nizovi Tipovi, opet Klase Opseg","title":"Java","url":"/java/index-2.html"}]