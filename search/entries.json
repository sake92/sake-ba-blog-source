[{"text":"Monads I know... yet another Monad tutorial. 🙃 Have you ever thought \"hmm, these all look kinda same\": Promise, Future, Rx, IO, Monad await, flatMap, do, for then you might be right! Let's see! First we'll see how and why the Monad abstraction came into Haskell (a purely functional programming language). Then we will see a nicer syntax for writing functions that operate on monads. And lastly I will show you that await/for/do is \"just nicer syntax\" for flatMap. Haskell A few relevant things about Haskell: it is a lazy language it wants to separate pure functions from impure functions (actions) Laziness By \"lazy\" we mean evaluation is not strict. In Java for example, when you call a function myFun(a, b), the order of evaluation is strict and consistent: first, the arguments are evaluated: left to right, one by one function is evaluated But in Haskell that's not the case. Nothing is evaluated until needed. So if the parameter a is not used in the body of myFun it will not be evaluated at all. This is fine+desirable+performant when your functions are pure (not doing anything), but it is a big issue when they do side effects: write to a file/db etc. For example, if you want these actions to be executed: f1 - write to a file f2 - read from that file you need to make sure that f1 always gets evaluated before f2 !!! In Haskell you are never sure 😱 because eval order is unspecified... The next Haskell will be strict. ~ Simon Peyton Jones Pure functions Pure functions are like mathematical functions, they do calculations, and only return new values (no mutable variables). They are only considering \"insides\" of a program, its own memory. Impure functions Impure functions go beyond our program, they \"go outside\", play and get dirty. They read/write to a file/console/database etc. Haskell wants you not to get dirty, and play as much as you can inside (stay safe). But how does it know which functions are \"impure\"? Well, by marking them with IO wrapper type (which is \"a monad\"). Main function \"Normal\" programming languages have a main function, which usually looks something like this: static void main(String[] args) {\n}\n but in Haskell you have this: main :: IO ()\nmain = ...\n Haskell marks the main as an IO action, so by definition it is impure. History and pre-history Before monads were introduced, main function's type looked like this: main :: [Response] -> [Request]. Example taken from StackOverflow: main :: [Response] -> [Request]\nmain responses =\n    [\n    AppendChan \"stdout\" \"Please enter a Number\",\n    ReadChan \"stdin\",\n    AppendChan \"stdout\" . show $ enteredNumber * 2\n    ]\n    where (Str input) = responses !! 1\n        firstLine = head . lines $ input\n        enteredNumber = read firstLine \n In a nutshell, you had to write all of the impure stuff that your whole program will do as a return value. That is represented as a list of requests: [Request]. Return values from those IO actions are delivered in the [Response] list, that you use inside the program logic. The number of responses is the same as the number of requests you gave. So you have to keep in mind the indices, which is a bummer. What if you add one request in the middle? You'd have to change all indices after it... Which request belongs to which response? That's really hard to see. We can already see that this way of writing a program is very cumbersome, unreadable, and limited. Notice also that the approach above works only because Haskell is lazy! Monads Explained Back to IO t. The IO t is an action that will do some side effects before returning a value of type t. This can be anything: writing to disk, sending HTTP requests etc. Examples of impure functions in Haskell: getChar :: IO Char\nputChar :: Char -> IO ()\n You are probably familiar with some functions that operate on the value inside the IO! For example, we have fmap :: Functor f => (a -> b) -> f a -> f b which transforms the value inside any Functor f (monad is a functor). But what about chaining, sequencing actions one after another? How can we ensure that getChar executes strictly before putChar? Monads to the rescue! Its core function is called flatMap (or bind, or >>= ..): (>>=) :: IO a -> (a -> IO b) -> IO b\n The flatMap function: takes an IO a action takes a function that takes a (the a from IO a) returns a new IO b So there we have it, Monad in all its glory! :) It's \"just\" a semicolon (;), duhh, sequencing operations. Let's see our solution now: echo = getChar >>= putChar\n\n-- or more verbosely\necho = getChar >>= (\\\\c -> putChar c)\n\n-- or verbosiest\necho = (>>=) getChar (\\\\c -> putChar c)\n In Scala you'd write val echo = getChar.flatMap(putChar). This is the reason why Monads were introduced in Haskell. In short, Haskell is the world's finest imperative programming language. ~ Simon Peyton Jones Syntax sugar for Monads Haskell and some other languages have built-in syntax for Monads. Haskell has \"do notation\" and Scala has \"for comprehensions\". It makes them more readable by flipping sides: echo = do\n    c <- getChar\n    putChar c\n Scala: val echo = for {\n    c <- getChar\n    _ <- putChar(c)\n} yield ()\n The <- symbol gets translated into >>= by Haskell's compiler. In case of Scala, it gets turned into a flatMap. It turns out that Monads are useful not only in the IO context, but for other types too. Whenever you have unwanted nesting like Wrapper[Wrapper[T]], you need to \"flatMap that shit\", hence you need a Monad. If you have List[List[String]] you probably needed a flatMap instead of map. If you have Option[Option[String]], same thing. You can imagine doing the same example above with a List[T], where c would be one element of the list. Async / Await After some time it came to my mind that we are doing a similar thing in JS/C#/Kotlin with await. It is almost the same thing, we are \"pulling a value from a Promise/Task\" (~Monads): async function fetchUserMovies() {\n    const user = await fetch('/user');\n    const movies = await fetch(`/user/${user.id}/movies`);\n    console.log(movies);\n    return movies;\n}\n Before this we used to write \"normal callback functions\": function fetchUserMovies() {\n    fetch('/user').then(user => {\n        fetch(`/user/${user.id}/movies`).then(movies => {\n            console.log(movies);\n            return movies;\n        });\n    });\n}\n Seems like then corresponds to flatMap, and await corresponds to <- syntax sugar. Some noticable differences: do/for is general, while await is specific just for Promise do/for in statically typed languages is checked for proper types, while in JS you're on your own My opinions To me, it feels very awkward to program in a lazy programming language. It is hard to reason about and you have to use monads for doing even the simplest IO operations. If you have a pure function and want to println a value.. nope, you gotta wrap everything in an IO.. wack. When used inside a normally strict language like Scala or Java, it \"spreads like a virus\". If you have an IO[String], all code that calls it must be an IO[..]!! It's viral! No bueno! You have to ask yourself: is all that complexity really worth it? IMHO it is not, 99% of the time. Especially today when we have JVM virtual threads. So, in my opinion, use Monads/Rx/whatever only when you have to! The simpler the program - the better. For example, in Java you can use threads and concurrent datastructures. Web servers like Tomcat, Jetty etc. are working just fine with a thread-per-request model. But in JS you don't have that liberty, you need to use Promises. That's because JS doesn't have \"normal threads\", is has only one thread with an event-loop so you have to program asynchronous code. I hope this gave you a better insight into scary Monads and the FP way of handling IO. Additional resources Tackling the Awkward Squad by Simon Peyton Jones Essential Effects by Adam Rosien State of Loom by Ron Pressler (comparing RX vs threads) Future vs IO by Diogo Castro The Observable disguised as an IO Monad by Luis Atencio Benefits of IO discussion on Reddit","title":"You already know Monad(ic) stuff","url":"/en/programming/monads.html"},{"text":"API First Scala There are many ways to build APIs: YOLO approach code-first approach API-first approach YOLO approach In the \"YOLO mode\" you don't care much about the users of your API. Maybe you have a few examples or docs you made, but nothing too serious. Code-first approach In the \"code-first\" approach you start with the coding right away. Schedules are tight, deadlines are near, pressure is real. The specification (if any) is mostly an afterthought. Consider Spring annotations, you can always sprinkle some @ApiParam here and there in your controllers. There are also approaches like Tapir, where you use a Scala DSL to define your API. Then you implement the server logic, and generate the spec from that Scala code. Potentially the client(s) too. This approach is popular, since you start with coding right away. But it has some downsides: you kinda play russian roulette with the spec, since it is generated from the code, so you can't really call it stable it is more code to maintain, increasing your cognitive load and compile times bundle size is increased, since you have to include the dependencies sometimes you have to fight the DSL to get what you want (e.g polymorphic payloads and such) you are limited by what DSL provides, if you need some framework-specific feature, it's challenging to get to it (or impossible) API-first approach In the \"API-first\" approach you start with the API specification. You define the API usually with OpenAPI (Swagger) in a YAML or JSON file. Then you generate the server from that spec (and client code if need be). This approach has some advantages: you are in full control of the spec, it is the source of truth spec is stable and versioned less code to maintain, there is no DSLs or annotations that obfuscate your code you can leverage your framework's features to the max An example in Scala is the Guardrail tool. It generates some server boilerplate code to the target/.../src_managed/main folder (you don't commit this to git). Then you implement the server logic by overriding those abstract definitions, fill in the blanks essentially. Note that when you change the openapi.yaml, the src_managed code is overwritten. Guardrail is a nice approach, sadly it doesn't support Scala 3 yet. A new kid on the block is the OpenApi4s tool that I made. It takes a bit different approach, it doesn't hide the server code from you, it generates it directly in your src folder. Exactly like you would have written it by hand. So how does it handle changes in the spec??? Overwrite the code every time? No, that would be silly, so let's see... OpenApi4s TLDR: OpenApi4s refactors your code automatically, by using regenesca diff+merge library. Generating the models and controllers is the easy part: parse the OpenAPI spec generate models generate controllers and that's it. The hard part is how to handle changes in the spec. Consider the classical PetStore spec. OpenApi4s will generate something like this for the User model: case class User(\n    id: Option[Long],\n    username: Option[String],\n    firstName: Option[String],\n    lastName: Option[String],\n    email: Option[String],\n    password: Option[String],\n    phone: Option[String],\n    userStatus: Option[Int]\n) derives JsonRW\n Adding a new property When you add a new age field of type integer to the User model. OpenApi4s will compare the newly generated case class User (in-memory), with the existing case class User in your source code. Then it will figure out that age: Int parameter is missing, and it will add it. --- a/api/src/com/example/petstore/api/models/User.scala\n+++ b/api/src/com/example/petstore/api/models/User.scala\n@@ -14,5 +14,5 @@ case class User(\n    email: Option[String],\n    password: Option[String],\n    phone: Option[String],\n-  userStatus: Option[Int]\n+  userStatus: Option[Int], age: Long\n    ) derives JsonRW\n Changing a property Let's say you change the userStatus's format from int32 to int64. OpenApi4s will figure out that userStatus: Option[Int] needs to be changed to userStatus: Option[Long]. --- a/api/src/com/example/petstore/api/models/User.scala\n+++ b/api/src/com/example/petstore/api/models/User.scala\n@@ -14,5 +14,6 @@ case class User(\n    email: Option[String],\n    password: Option[String],\n    phone: Option[String],\n-  userStatus: Option[Int]\n+  userStatus: Option[Long]\n Adding a new endpoint Adding a new endpoint to existing controller is easy too. It will just add another case to your existing routes. For example in sharaf framework it will add something like this: case GET -> Path(\"user\", \"new-endpoint\") =>\n    Response.withStatus(StatusCodes.NOT_IMPLEMENTED)\n It will even generate a boilerplate implementation for you. You can then fill in the blanks. Changing an endpoint Now this is a bit more tricky. OpenApi4s must not touch your existing code, since you might have already implemented some logic. So it will not touch your existing expressions, for example Response.withStatus(..) in the previous example. But it will update the query parameters if needed. CI Preventing accidental overwrites You might be cautious about the changes that OpenApi4s makes. Thinking, will it overwrite my code? How can I make sure it doesn't? A simple check you can do in your CI pipeline is to: touch the openapi.yaml file, just so that mill detects a change and triggers openapi4s compile the code, to regenerate the files see if there are any changes in the git diff Example: echo \" \" >> api/resources/openapi.yaml\n./mill api.compile\ntruncate -s -1 api/resources/openapi.yaml\ngit diff --exit-code\n[ $$? -eq 0 ]  || exit 1\n Preventing breaking changes Since the openapi.yaml is now in git, you can do some cool stuff with it. One very useful check is preventing breaking changes. You can do it with openapi-diff for example: git show origin/main:api/resources/public/openapi.json > main_openapi.json\n\ncs launch org.openapitools.openapidiff:openapi-diff-cli:2.1.0-beta.12 -M org.openapitools.openapidiff.cli.Main -- --fail-on-incompatible main_openapi.json ./api/resources/public/openapi.json\n[ $$? -eq 0 ]  || exit 1\n\nrm main_openapi.json\n See the CI script in the openapi4s demo repo. Here is an example of compatible change PR. And an example of breaking change PR, CI fails of course. Conclusion Hope you find this post (and OpenApi4s tool) useful. You can find more tools to combine with api-first approach at https://openapi.tools/ Check out the video demo on YouTube! Additional resources Understanding the API-First Approach Guardrail Tapir Documenting a Spring REST API Using OpenAPI 3.0","title":"API First Scala","url":"/en/programming/api-first-scala.html"},{"text":"This content is not available in your country. Sorry about that. :/ Just kidding, there's nothing here! ^_^ Go back to homepage","title":"Not found","url":"/404.shtml"},{"text":"Varijable Varijable nam služe za spremanje informacija/podataka. Recimo ako računamo prosjeke ocjena učenika (npr. ima 29 učenika trenutno), morali bi napisati broj 29 više puta u programu. Ako dođe novi učenik, morali bi na svim mjestima u programu izmijeniti 29 na 30... Varijable nam pomažu da izbjegnemo ovakve situacije. Svaka varijabla ima naziv i tip. Tip nam ograničava šta možemo spremiti u tu varijablu: Integer - cijeli broj Real - realni broj String - tekst Boolean - jeste/nije (engl. true/false) Napravićemo program koji će izračunati obim kvadrata. Za to će nam trebati 2 varijable: a: Integer - dužina stranice kvadrata obim: Integer - rezultat Deklaracija i dodjela varijable U donjem prozoru uradite sljedeće: deklarišite varijablu a: kliknite na strelicu odaberite Declare kliknite na novi Declare blok i unesite naziv a. Primijetite da varijabla već ima tip Integer. Kasnije ga možemo promijeniti po potrebi. dodijelite vrijednost varijabli a: kliknite na strelicu ispod deklaracije a varijable odaberite Assign kliknite na novi Assign blok i unesite naziv a i vrijednost 5 Ovdje ćemo malo zastati. Prvo probajte ispisati varijablu a na ekran. To smo naučili u prethodnoj sekciji! Malo terminologije: deklaracija znači \"uvođenje varijable\", kažemo programu da želimo koristiti tu varijablu. Nakon deklaracije, varijabla nema nikakvu vrijednost spremljenu u sebi! (možemo joj dati početnu vrijednost, što je dobra praksa) dodjela varijable (engl. assignment) znači \"dodjela vrijednosti varijabli\" Varijabli možemo dodijeliti vrijednost više puta tokom programa! Obim kvadrata Nastavićemo sa pravljenjem programa za računanje obima kvadrata. Dodaćemo još jednu varijablu, Integer obim koja će sadržati rezultat, obim kvadrata. Naravno, varijablama smo mogli dati bilo koji drugi naziv: xyz, fdgfdgfdxcv itd. Ali varijable moraju imati smislene nazive, da bi kasnije mogli lakše razumjeti program. Dodijelićemo varijabli obim ovu vrijednost: a * 4. Kada ispišemo obim i pokrenemo program, trebali bi dobiti vrijednost 20.","title":"Varijable","url":"/flowrun/variables.html"},{"text":"Do While petlja Ova naredba je slična While. Glavna razlika je da Do While provjerava uslov tek nakon što izvrši naredbe. Do While će izvršiti blok naredbi minimalno jednom. Napravićemo program koji čita broj od korisnika, koji mora biti pozitivan: deklarišite Integer x dodajte Do While sa uslovom x <= 0 unesite x u tijelu D oWhile Ovaj program možemo pročitati ovako: \"Unesi broj x, dok god je manji ili jednak nuli\" Kada pokrenete program probajte unijeti sljedeće vrijednosti: 1, 17, -55, 6. Do While će završiti samo kada unesete pozitivan broj. Vježbe Unosite String s i ispišite ga, sve dok ne bude jednak \"END\" Unosite jednu po jednu ocjenu dok korisnik ne unese 0. Zatim ispišite prosjek tih ocjena","title":"Do While petlja","url":"/flowrun/do-while.html"},{"text":"If naredba Već smo vidjeli kako program izvršava naredbe jednu nakon druge, odozgo ka dole. Ali uglavnom će nam trebati i neko uslovno izvršavanje, program će morati \"donositi odluke\" tokom izvršavanja. Napravićemo program koji će ispisati da li je broj pozitivan ili negativan: deklarišite x: Integer odradite unos x dodajte If blok s vrijednošću x > 0 u true grani ispišite \"pozitivan\" u false grani ispišite \"negativan\" Npr. ako korisnik unese broj 9, izlaz će ispisati \"pozitivan\". Ako korisnik unese -57 ispisaće \"negativan\". Izraz x > 0 ima tip Boolean. Boolean može imati vrijednost true ili false. Komplikovaniji uslovi I operator U gornjem primjeru koristili smo izraz x>0 koji je Boolean. Šta ako nam treba neki komplikovaniji izraz? Npr. ako želimo povjeriti je li broj pozitivan i manji od 50. Za to nam treba operator \"I\" (engl. \"and\"), koji pišemo kao &&. Dakle, napisali bi x>0 && x<50. Da se podsjetimo \"tablice istinitosti\" za I operaciju: A B A && B true true true true false false false true false false false false Vidimo da je uslov ispunjen samo kada su oba uslova ispunjena. ILI operator Kada imamo 2 moguća uslova, od kojih nam bilo koji odgovara, tada koristimo operator \"ILI\" (engl. \"or\"), koji pišemo kao ||. Npr. x==\"abc\" || x==\"ABC\" izraz kaže da x mora biti jednak \"abc\" ili \"ABC\". Ako je bilo koje od ovo dvoje ispunjeno, i cijeli izraz biće ispunjen/istinit. A B A || B true true true true false true false true true false false false NE operator Na kraju, imamo i operaciju negacije, koja samo \"obrne\" vrijednost Booleana. Na bosanskom se čita \"NE\" (engl. \"not\"), a pišemo je kao !. Ovaj operator piše se prije vrijednosti koju negiramo, npr. !uslov. A !A true false false true","title":"If naredba","url":"/flowrun/ifs.html"},{"text":"Osnove Svaki program ima svoj početak i kraj. Početak je označen sa Begin, kraj je označen sa End. Strelica pokazuje na iduću naredbu koja se treba izvršiti. Ako kliknemo na dugme Run (▶), program će se pokrenuti i odmah završiti! Nije se ništa značajno desilo, samo vidimo u output panelu da je program završio. Hajde da ispišemo nešto na ekran: kliknite na strelicu, prikazaće se lista naredbi koje možemo dodati kliknite na Output kliknite na novu Output naredbu upišite \"Pozdrav svijete!\", sa navodnicima! kliknite Run Program sada ispisuje poruku \"Pozdrav svijete!\" u izlaznom panelu. Vježbe Čestitam, napisali smo svoj prvi program! Probajte odraditi sljedeće vježbe: Ispis Ispišite 123 na ekran Ispišite 12 + 3 na ekran Ispišite 3.14 na ekran (brojevi sa zarezom se ustvari pišu sa tačkom!) Matematičke operacije Naravno, možemo raditi matematičke operacije nad brojevima. Ispišite sljedeće izraze: 10 + 3 10 - 3 10 * 3 10 / 3 10 % 3 Zadnja operacija je malkice misteriozna. Ona daje cjelobrojni ostatak pri dijeljenju. Npr. 10 / 3 je 3 i ostatak 1. Tako da je 10 % 3 = 1. Naravno, možemo koristiti zagrade ako nam trebaju: (2 + 2) * 2 2 + (2 * 2) Spajanje teksta U prethodnim primjerima ispisivali smo neke jednostavne tekstualne vrijednosti. Nekad nam treba da te vrijednosti spojimo u jednu. Za to nam služi znak +: \"abc\" + \"xyz\" bi ispisalo isto kao i \"abcxyz\" \"abc\" + 5 je isto kao \"abc5\" Probajte razne kombinacije, brojeve sa zarezom itd. Probajte spojiti više od 2 vrijednosti! Malo terminologije: tekst koji se piše sa navodnim znacima, npr. \"Meho\" naziva se String broj bez zareza naziva se Integer (engl. \"cijeli broj\") broj sa zarezom/tačkom naziva se Real (engl. \"realni broj\")","title":"Basics","url":"/flowrun/basics.html"},{"text":"While petlja Kada želimo da ponovimo dio koda više puta, uvijek možemo copy-paste te naredbe. Naravno, to nije uvijek efikasno niti moguće. Npr. kada želimo ponoviti dio koda pod nekim uslovom, može biti 0 ili n puta.. Za to nam služi While naredba/petlja. While ima 2 dijela: uslovni izraz - provjerava se svaki put prije izvršavanja tijela petlje tijelo (engl. body) - naredbe koje se izvršavaju kada je uslov ispunjen Napravićemo program koji ispisuje brojeve od 1 do 5: deklarišite Integer x = 1 dodajte While sa uslovom x <= 5 ispišite x u tijelu While dodijelite x = x + 1 nakon ispisa Kada pokrenete program trebali bi vidjeti brojeve 1,2,3,4,5 ispisane na izlaznom panelu. Primijetite da smo u dodjeli x = x + 1 koristili prethodnu vrijednost x-a! U izrazu x+1, x se odnosi na zadnju vrijednost prije ove naredbe. Vježbe Ispišite brojeve od 1..20 koji su djeljivi sa 3 Za uneseni n ispišite sljedeće drvo (primjer za n=4): 1 22 333 4444","title":"While petlja","url":"/flowrun/while.html"},{"text":"Rekurzivne funkcije Sada se pripremite za nešto od čega će vas zaboljeti glava. Nemojte se brinuti ako ne \"skopčate\" odmah ovaj koncept, čak ni neki dugogodišnji programeri \"nisu načisto\" sa rekurzijom. :) Funkcije mogu pozivati funkcije! Da.. to smo već vidjeli, \"main\" je pozvao funkciju \"kvadrat\". Ali šta ako funkcija pozove samu sebe!?? Da, i to je moguće, i vrlo korisno u nekim slučajevima. Napisaćemo rekurzivnu funkciju koja odbrojava od x do 1: dodajte novu funkciju countdown dodajte joj parametar Integer x dodajte If sa uslovom x > 0 ispišite x u true grani pozovite countdown(x-1) nakon ispisa pozovite countdown(5) u main funkciji Pokrenite program, ispisaće 5, 4, 3, 2, 1. Kako ova magija radi?? Kada je countdown pozvana sa argumentom 5, ispisaće ga i pozvati countdown(4). Zatim će ispisati 4 i pozvati countdown(3). Zatim će ispisati 3 i pozvati countdown(2). Zatim će ispisati 2 i pozvati countdown(1). Zatim će ispisati 1 i pozvati countdown(0). U ovom trenutku uslov će biti false tako da će se funkcija završiti. Tek kada se ovaj poziv funkcije završi, kreće se sa \"odmotavanjem\": završiće se poziv countdown(1) završiće se poziv countdown(2) završiće se poziv countdown(3) završiće se poziv countdown(4) završiće se poziv countdown(5) završiće se main Najbitniji dio je bazni/završni slučaj tj. uslov završetka rekurzije. To je ova false grana, jer npr. kad ne bi imali ovaj If uslov, rekurzija se nikad ne bi završila. U tom slučaju program bi se zaledio i morali bismo ga zaustaviti (klikom na Stop dugme). Možete probati pozvati main u mainu, doći će do beskonačne rekurzije.","title":"Rekurzivne funkcije","url":"/flowrun/recursive-functions.html"},{"text":"For petlja Ova naredba je malo komplikovanija. For petlja sadrži sljedeće dijelove: naziv varijable početna vrijednost - start krajnja vrijednost - end inkrement/korak - step tijelo/naredbe Izvršavanje For petlje je isto kao sljedeće: Deklarisanje i: Integer sa početnom vrijednošću While petlja sa uslovom i <= end i tijelom Assign i = i + step na kraju While Napravićemo program isti kao za While petlju, printanje prvih 5 brojeva: deklarišite For petlju sa varijablom i početna vrijednost je 1 krajna vrijednost je 5 korak je 1 ispišite i u tijelu For petlje Postigli smo isti rezultat kao sa While, samo sa dosta manje koda! Plus, ovako je dosta čitljivije. Vježbe Ispišite svako 5-i broj od 0..50 Ispišite tablicu množenja od 1 do 10 Izračunajte faktorijel broja 7","title":"For petlja","url":"/flowrun/for.html"},{"text":"Povratna vrijednost funkcije U prethodnom dijelu vidjeli smo kako možemo grupisati dio koda u funkciju. Funkciju možemo parametrizovati sa argumentima kada ju pozivamo. Funkcije također mogu da vrate vrijednost. Hajde da napravimo funkciju kvadrat(x). Izračunat će kvadrat broja x i vratiti ga kao vrijednost: dodajte novu funkciju kvadrat sa tipom Integer dodajte novi parametar Integer x kliknite na return element i upišite x*x u main funkciji ispišite kvadrat(5) Program će ispisati 25 kada ga pokrenete.","title":"Povratna vrijednost funkcije","url":"/flowrun/return-of-functions.html"},{"text":"Ugrađene funkcije Vidjeli smo kako izračunati jednostavne matematičke izraze sa operatorima +, -, *, / i %. Za Boolean izraze imamo operatore &&, || i !. Za Stringove imamo operator +, koji ih nadovezuje, \"štikla\" ih. U \"pravim\" programima ne izmišljamo toplu vodu, već iskorištavamo postojeći kod. Taj kod može biti \"ugrađen\" u sami jezik, ili kod koji smo mi napisali. Moramo negdje \"spremiti\" taj kod, parametrizirati ga ako je potrebno. Za to nam služe funkcije! Hajde da vidimo neke od ugrađenih/predefinisanih funkcija. Probajte ispisati sljedeće izraze: abs(-456.31) real2int(3.14) length(\"abcd\") randomInt(10) Sintaksa je ista kao i u matematici, napišemo ime funkcije, a u zagradama navedemo argumente koji su razdvojeni zarezom. Gornji izrazi se nazivaju \"pozivanje funkcije\" (engl. \"invoke\").","title":"Ugrađene funkcije","url":"/flowrun/predefined-functions.html"},{"text":"Definisanje funkcije Predefinisane funkcije su super. Ali još bolje je kada znamo napisati svoju funkciju! Prije nego nastavimo, moram spomenuti da već imamo jednu funkciju koja se zove \"main\". Ova funkcija je vrlo važna, jer je ona funkcija od koje počinje izvršavanje programa kada pritisnete Play. Hajde da definišemo funkciju pozdrav(ime): dodajte novu funkciju u lijevom panelu kliknite na fun1 na dijagramu i promijenite ime u pozdrav kliknite + da dodate novi parametar String ime ispišite \"Pozdrav \" + ime kliknite na main funkciju dodajte novu Call naredbu i upišite pozdrav(\"Meho\") Program bi trebao ispisati Pozdrav Meho.","title":"Definisanje funkcije","url":"/flowrun/custom-functions.html"},{"text":"Unos podataka U prethodnim primjerima koristili smo vrijednosti koje su ufiksane u program. Npr. vrijednost 5 za dužinu stranice kvadrata. Bilo bi zgodno kada bi mogli dati korisniku da unese proizvoljnu vrijednost. Naravno, to je moguće, i za to služi naredba Input. U donjem prozoru uradite sljedeće: deklarišite varijablu ime: String nakon nje dodajte Input naredbu kliknite na novu Input naredbu i unesite ime. Ovo znači da kada program dođe do ove linije, pitaće korisnika da unese svoje ime. Vrijednost koju korisnik upiše program će spremiti u varijablu ime ispišite ime Program sada čeka da unesemo neki tekst. Unesite svoje ime i kliknite Enter. Vidimo da program odgovara ispisom u izlaznom panelu. Vježbe Izmijeniti primjer sa kvadratom, omogućiti korisniku da unese dužinu stranice. Napraviti program za unos 2 stranice pravougaonika, zatim ispisati njegov obim.","title":"Unos podataka","url":"/flowrun/user-input.html"},{"text":"Teorija skupova Teorija skupova (en. Set theory) je jedna od osnovnih grana matematike. Ona, između ostalog, daje odgovor na to da li neki objekat pripada datom skupu objekata. Skup mora biti jasno i nedvosmisleno definisan. Skup kao pojam se obično ne definiše već se uzima kao osnovni pojam (aksiom). To je ustvari samo kolekcija/mnoštvo različitih objekata (stvari). Objekat koji pripada skupu naziva se element skupa. Element skupa može biti bilo šta, npr. broj, jabuka, avion, ili čak skup! Vidimo da su skupovi vrlo liberalni, pa se često koriste u raznim oblastima matematike i nauke. Skupovi se označavaju velikim štampanim slovima: AAA, BBB, ... a elementi malim slovima xxx, yyy, ... Definicija se navodi u vitičastim zagradama, npr. A={1,2,3}A=\\{1,2,3\\}A={1,2,3}. Redoslijed elemenata nije bitan: A={1,2,3}={3,2,1}={2,1,3}A=\\{1,2,3\\} = \\{3,2,1\\} = \\{2,1,3\\}A={1,2,3}={3,2,1}={2,1,3}. Zato se kaže da je skup neuređena kolekcija. Ne postoji prvi, drugi element i sl. Obično se u matematici koristi neko pravilo koje elementi moraju zadovoljavati (umjesto navođenja elemenata pojedinačno...), npr. \"skup svih prirodnih brojeva koji su manji od 5\". To možemo zapisati ovako: {x∣x∈N,x<5}\\{x | x \\in \\mathbb{N}, x \\lt 5\\}{x∣x∈N,x<5}. Ovdje xxx označava neki element skupa, ∣|∣ se čita kao \"takav da je\", a zarez se čita kao logičko \"i\" (en. and). Negdje se koristi i dvotačka umjesto | znaka, npr. {x:x∈N,x<5}\\{x : x \\in \\mathbb{N}, x \\lt 5\\}{x:x∈N,x<5}. Dva skupa su jednaka akko imaju iste elemente. To pišemo kao A=BA=BA=B, logično... :D Ovo \"akko\" je skraćeno od \"ako i samo ako\" (en. iff - if and only if). Razlika između \"ako\" i \"akko\" je sljedeća: Kada kažemo \"ako A onda B\" ne mora značiti da \"ako B onda A\"! Ali, kada kažemo \"akko A onda B\" tada MORA biti i \"akko B onda A\"! Primjer: Kod iskaza \"Ako grije Sunce onda je dan.\" ne mora značiti da ako je dan da grije Sunce... Možda je oblačno! Vidimo da ovdje ne možemo koristiti akko. Dok npr. iskaz \"Trougao je jednakostranični akko su mu svi uglovi od 60o60^o60o\" je validan. Zašto? Zato što vrijedi i obrnuto, ako su svi uglovi trougla od 60o60^o60o onda je on jednakostranični. Logično. Postoji nekoliko skupova koji se često pojavljuju u matematici i imaju posebne simbole: ∅\\emptyset∅ - Prazan skup. Skup koji ne sadrži nijedan element. Označava se i sa {}\\{\\}{}. N\\mathbb{N}N - Skup prirodnih brojeva (od en. Natural - prirodni). N={0,1,2,...}\\mathbb{N} = \\{0,1,2,...\\}N={0,1,2,...}. Neki autori ne uključuju nulu u ovaj skup. Zato kada se želi posebno istaći da je i nula uključena koriste se simboli N0N_0N0, N0N^0N0. Kada se želi istaći da nula nije uključena piše se N+={1,2,...}N^+ = \\{1,2,...\\}N+={1,2,...}. Analogna notacija vrijedi i za ostale skupove. Z\\mathbb{Z}Z - Skup cijelih brojeva (od njem. Zahl - broj, en. integer). Z={0,1,−1,2,−2,...}\\mathbb{Z} = \\{0,1,-1,2,-2,...\\}Z={0,1,−1,2,−2,...}. Q\\mathbb{Q}Q - Skup racionalnih brojeva (od en. Quotient - razlomak). Svaki broj koji može biti predstavljen razlomkom pq\\frac{p}{q}qp gdje su ppp i qqq dva cijela broja. Naravno, qqq ne smije biti nula jer bi dijeljenjem dobili ∞\\infty∞ (beskonačno)... R\\mathbb{R}R - Skup realnih brojeva (od en. Real - pravi). Za nas obične smrtnike ovo su \"brojevi sa zarezom\". C\\mathbb{C}C - Skup kompleksnih brojeva (od en. Complex - složeni). To su brojevi koji pored realnog sadrže i imaginarni dio. Kada neki element xxx pripada skupu AAA to pišemo sa x∈Ax \\in Ax∈A. Npr. 1∈{2,1}1 \\in \\{2,1\\}1∈{2,1}. Kada neki element xxx ne pripada skupu AAA to pišemo sa x∉Ax \\notin Ax∈/A. Kako smo već rekli, skup može sadržati bilo šta. Da vidimo par zanimljivih primjera: Ako imamo skup A={{1,2},{2,3},4}A = \\{\\{1,2\\},\\{2,3\\},4\\}A={{1,2},{2,3},4} tada 1∉A1 \\notin A1∈/A. Zašto? Pa zato što 111 nije direktno u skupu! Skup AAA sadrži dva skupa i broj 444! Za bilo koje xxx vrijedi x∉∅x \\notin \\emptysetx∈/∅. Ili napisano hijeroglifima: ∀x,x∉∅\\forall x, x \\notin \\emptyset∀x,x∈/∅. Ako imamo A={∅}A = \\{\\emptyset\\}A={∅} vrijedi ∅≠A\\emptyset \\not = A∅=A. Štaaa? A je skup koji sadrži prazan skup. Što nije isto kao i prazan skup. Simbol ∀\\forall∀ znači \"za svako\". Npr. ∀x,tvrdnja\\forall x, tvrdnja∀x,tvrdnja se čita kao \"za svako x vrijedi tvrdnja\". U paru ide i simbol ∃\\exists∃ koji se čita kao \"postoji (bar jedno)\" ili \"ima\". Operacije nad skupovima Pošto element skupa može biti bilo šta, obično se ograničavamo samo na određeni tip stvari tj. na neki skup. Npr. kada govorimo o cijelim brojevima ne zanimaju nas imaginarni brojevi, jabuke i auta... Skup stvari o kojima se trenutno govori naziva se univerzalni skup, ili kraće univerzum. Označava se sa UUU. Skupovi i relacija (odnosi) između skupova se mogu grafički predstaviti Venovim dijagramom. Na slici desno vidimo primjer s dva skupa: A={1,2,4}A = \\{1,2,4\\}A={1,2,4} i B={2,3}B = \\{2,3\\}B={2,3}. Univerzum ( UUU) je pravougaonik koji obuhvata ova dva skupa. Recimo da je to skup N\\mathbb{N}N. To je igralište iz kojeg ne smijemo izlaziti. Unija Unija dva skupa AAA i BBB označava se sa A∪BA \\cup BA∪B. Primijetite da ovo nije obično slovo U već specijalni simbol, mada izgleda kao ∪\\cup∪nija. Unija predstavlja novi skup koji sadrži sve elemente skupa AAA i sve elemente skupa BBB. U našem primjeru to bi bilo A∪B={1,2,3,4}A \\cup B = \\{1,2,3,4\\}A∪B={1,2,3,4}. Skup ne mora bit predstavljen krugom, niđe veze... xD Dobro zapažanje! Uniju možemo formalno zapisati kao A∪B={x∣x∈A∨x∈B}A \\cup B = \\{x | x \\in A \\lor x \\in B\\}A∪B={x∣x∈A∨x∈B}. Znak ∨\\lor∨ se čita kao \"ili\". Znak ∧\\land∧ se čita kao \"i\". O logičkim operatorima ćemo reći nešto više u idućem poglavlju. Presjek Često se postavlja pitanje šta dva skupa imaju zajedničko. Presjek dva skupa AAA i BBB označava se sa A∩BA \\cap BA∩B. Presjek predstavlja novi skup koji sadrži one elemente koji se nalaze i u AAA skupu i u BBB skupu. U našem primjeru to bi bilo A∩B={2}A \\cap B = \\{2\\}A∩B={2} (na slici obojeno crvenom bojom!). Presjek možemo formalno zapisati kao A∩B={x∣x∈A∧x∈B}A \\cap B = \\{x | x \\in A \\land x \\in B\\}A∩B={x∣x∈A∧x∈B}. Šta ako skupovi nemaju ništa zajedničko? Rezultat je, naravno, prazan skup, ∅\\emptyset∅ tj. {}\\{\\}{}. Prazan skup ipak ima neku svrhu... :D Za ovakve skupove, koji nemaju zajedničke elemente, kaže se da su disjunktni. Matematika se često bavi pitanjem jednakosti, kako možemo jednu te istu stvar izraziti na više načina. Ti rezultati nam mogu koristiti za skraćivanje algebarskih izraza, optimizacije i sl. Za uniju možemo reći da je komutativna. Vrijedi da je A∪B=B∪AA \\cup B = B \\cup AA∪B=B∪A, što nije teško razumjeti. Također, ova operacija je i asocijativna. Vrijedi da je A∪(B∪C)=(A∪B)∪CA \\cup (B \\cup C) = (A \\cup B) \\cup CA∪(B∪C)=(A∪B)∪C, tj. redoslijed nije bitan. Sada možemo pisati i A∪B∪CA \\cup B \\cup CA∪B∪C... Sve navedeno vrijedi i za operaciju presjek! Razlika Možemo postaviti i pitanje u čemu se skup AAA razlikuje od skupa BBB. Ova operacija se naziva razlika. Razlika skupova AAA i BBB označava se sa A BA \\ BA B. Čita se kao \"A razlika B\". Razliku čine elementi skupa AAA koji se ne nalaze skupu BBB. U našem primjeru to bi bilo A B={1,4}A \\ B = \\{1,4\\}A B={1,4}. Razliku možemo formalno zapisati kao A∖B={x∣x∈A∧x∉B}A \\setminus B = \\{x | x \\in A \\land x \\notin B\\}A∖B={x∣x∈A∧x∈/B}. Postoje još dvije zanimljive operacije, prva je simetrična razlika ( Δ\\DeltaΔ). Simetrična razlika predstavlja uniju razlika skupova AAA i BBB, tj. AΔB=(A B)∪(B A)A \\Delta B = (A \\ B) \\cup (B \\ A)AΔB=(A B)∪(B A). Kroz naš primjer bilo bi AΔB={1,3,4}A \\Delta B = \\{1,3,4\\}AΔB={1,3,4} Druga operacija je komplement skupa. Komplement skupa AAA su svi elementi koji nisu u skupu AAA, tj. A‾={x∈U∣x∉A}\\overline{A} = \\{x \\in U | x \\notin A\\}A={x∈U∣x∈/A}, gdje je UUU neki univerzum. Negdje se naziva i apsolutni komplement. Kroz naš primjer bilo bi A‾={0,3,5,6,...}\\overline{A} = \\{0,3,5,6,...\\}A={0,3,5,6,...}, pri čemu je U=NU=\\mathbb{N}U=N. Druge oznake su A′A'A′ i ACA^CAC. De Morganovi zakoni Dvije vrlo korisne formule vezane za komplemente skupova su De Morganovi zakoni: A∪B‾=A‾∩B‾\\overline{A \\cup B} = \\overline{A} \\cap \\overline{B}A∪B=A∩B A∩B‾=A‾∪B‾\\overline{A \\cap B} = \\overline{A} \\cup \\overline{B}A∩B=A∪B Relacije između skupova Kao što smo već rekli na početku, skupovi su određeni samo elementima koje sadrže. To nam je dovoljno da odredimo da li su dva skupa jednaka, A=BA = BA=B akko ∀x∣x∈A∧x∈B\\forall x | x \\in A \\land x \\in B∀x∣x∈A∧x∈B. Podskup i nadskup Za skup AAA kažemo da je podskup skupa BBB ako su svi elementi skupa AAA također elementi skupa BBB. Ako je AAA podskup od BBB pišemo A⊆BA \\subseteq BA⊆B. (Znak ⊆\\subseteq⊆ podsjeća na ≤\\le≤, zar ne?) Da, može biti i slučaj da je A=BA=BA=B! Ako A≠BA \\not = BA=B (nisu isti skupovi) i A⊆BA \\subseteq BA⊆B tada za AAA kažemo da je pravi podskup skupa BBB. Piše se A⊂BA \\subset BA⊂B. Analogno, imamo i relaciju nadskup ( A⊇BA \\supseteq BA⊇B) za koju vrijedi obrnuto od relacije podskup. Kakav je slučaj sa praznim skupom? Da li je ∅⊆A\\emptyset \\subseteq A∅⊆A? Primijenimo definiciju: \"Svaki element ∅\\emptyset∅ (a nema nijedan) je element skupa AAA. Hm, zanimljivo fakat... Imamo dvije opcije: Jeste, jer nema nijedan element skupa ∅\\emptyset∅ koji nije element skupa A.A.A. Nije, jer nema nijedan element skupa ∅\\emptyset∅ koji je element skupa A.A.A. Logičari kažu da jeste (prva opcija) i vjerovaćemo im na riječ... xD Kažu da je ovo primjer \"prazne istine\" jer za prazan skup možemo tvrditi šta god želimo... Otprilike. Kardinalnost skupa Kardinalnost skupa je mjera broja elemenata nekog skupa. Npr. naš skup A={1,2,4}A = \\{1,2,4\\}A={1,2,4} ima 3 elementa. Pišemo ∣A∣=3|A|=3∣A∣=3. Kod konačnih skupova, kardinalnost je obični broj, dok je kod beskonačnih.. kako-kad, komplikovano je! Nećemo u detalje. Reći ćemo samo da postoji više beskonačnosti! Npr. ∣N∣≠∣Z∣|\\mathbb{N}| \\not = |\\mathbb{Z}|∣N∣=∣Z∣. Ne zaboravimo i ∣∅∣=0|\\emptyset|=0∣∅∣=0, naravno.","title":"Teorija skupova","url":"/maths/set_theory.html"},{"text":"Paradigme programiranja Jedan od značajnijih problema koje p.j. pokušavaju riješiti je kompleksnost. Kako programi postaju veći, to su komplikovaniji za razumjeti. Zato danas imamo nekoliko paradigmi (pristupa, načina) za razvijanje programa, od kojih su najpoznatije: proceduralno funkcionalno - FP objektno orijentisano - OOP Dosta jezika danas je miks dvije ili više ovih paradigmi. Ove paradigme usmjeravaju naš način razmišljanja o problemima po svom nekom šablonu/fazonu. Npr. kod proceduralnog/imperativnog načina razmišljanja mijenjamo varijable \"u mjestu\". Ovdje moramo pamtiti/zamisliti koja je vrijednost neke varijable u datom trenutku, što je većini ljudi izazovan zadatak. Kod FP/matematičkog načina razmišljanja pravimo nove varijable a stare ne diramo! To nam pomaže kod razumijevanja određenog dijela koda, ne moramo pamtiti u glavi stanje \"cijelog svijeta\" i na šta utiče promjena date varijable. OOP objedinjuje podatke sa funkcijama(metodama) koje rade sa tim podacima. Taj objedinjeni koncept naziva se objekat. OOP nam pomaže i da sakrijemo neke podatke i funkcije za koje korisnici(drugi dijelovi koda) ne moraju znati. Ovdje veliku ulogu ima kompajler koji nas ograničava i usmjerava nas u tim slučajevima. OOP Ovo što smo do sada radili u Javi je proceduralno programiranje. Koristili smo procedure/funkcije i mijenjali varijable u mjestu. Klase smo koristili da kreiramo objekte koji sadrže samo podatke. U OOP klase ćemo koristiti na malo fleksibilniji način.","title":"Paradigme programiranja","url":"/programming/paradigms.html"},{"text":"Programerska Terminologija deklaracija Za liniju int i; kažemo da je deklaracija varijable i. Njome uvodimo novo ime u našem programu, u ovom slučaju varijablu. U suštini, samo kažemo da postoji ta varijabla. Može se deklarisati i metoda, klasa, interfejs i sl. definicija Linija i = 5; je definicija varijable i. Ovdje navodimo šta ustvari jeste ta varijabla (ili metoda, klasa, štagod). izraz (expression) Izraz je nešto što ima vrijednost. Bio to broj, string ili neki objekat. Npr. 2 + 2 je izraz. Poziv metode koja vraća vrijednost je izraz, npr. obj.getString(). Naravno, svaki izraz možemo dodijeliti nekoj varijabli i sl. izjava (statement) Za razliku od izraza, izjave nemaju vrijednost (ili imaju beskorisnu vrijednost, npr. Unit u Scali). Npr. za i = 5; i System.out.println(i); kažemo da su izjave. Neke izjave koriste sintaksu ugrađenu u sami jezik, npr. dodjela vrijednosti (znak jednako: =). Ostale naredbe obično imaju naziv u imperativnom obliku: \"print\", \"calculate\", \"uradiOvo\"... Zato se za Javu i slične jezike kaže da su imperativni jezici (jer preferiraju ovaj stil programiranja).","title":"Untitled","url":"/programming/terminology.html"},{"text":"Filozofija programiranja Mi ljudi za sebe tvrdimo da smo inteligentna bića. Jedan od dokaza za to je i mnoštvo naših načina komunikacije. Komunikacija podrazumijeva razmjenu informacija između dva ili više učesnika (ne moraju biti ljudi), koristeći zajedničke znakove i pravila. U ovo se ubrajaju audio metode (govor, muzika), vizuelne metode (znakovni jezici, grimase, kolutanje očima), fizičke metode (kad vas neko udari jer ste nepristojni npr.). Danas u svijetu postoji više od 5.000 jezika, od kojih većina, nažalost, lagano izumire. Ljudi pričaju i sa robotima, ako ništa gledali ste futurističke filmove. Za nas ljude to je idealan način za komuniciranje. Međutim, mašine su u suštini vrlo glupe, nemaju inteligenciju kao živa bića. Mašine nemaju mozak, tijelo, uši, glasne žice... Sve im to moramo obezbijediti, da bi bile \"inteligentne\". Neki od tih organa su predstavljeni kompjuterom, mehaničkim dijelovima, mikrofonom, zvučnikom itd. Kompjuter je mozak mašine, on upravlja svime. Na njega su povezani svi ostali uređaji (organi). Nama ljudima misli dolaze same od sebe (većini, neki ljudi ne misle nikako), ali kompjuterima ne. I to im moramo \"ručno\" unijeti... Te kompjuterske misli su ustvari naše naredbe, koje se skupno nazivaju program. Ovdje smo da naučimo neke od načina za komuniciranje sa kompjuterima. Naime, ljudi su razvili na stotine programskih jezika koje se koriste za pisanje kompjuterskih programa. Ovi jezici su slični našim jezicima, imaju svoju sintaksu, gramatiku i pravopis. Apstrakcije Kroz život, svjesno ili nesvjesno, naučili smo koristiti apstrakcije. Apstrakcija je ustvari generalizovanje, uopćavanje nečeg konkretnog. U datom kontekstu bitna su nam samo neka svojstva datog objekta/stvari/koncepta. Naprimjer kada kažemo automobil, podrazumijevamo nešto sa 4 točka, motorom itd. To je apstraktni automobil, njegova takoreći definicija, dok je konkretan automobil npr. komšijin Peugeot 307, iz 2001. godine. U fizici i hemiji imamo apstrakciju atoma. Zatim se uvodi apstrakcija molekule, koja se sastoje od više atoma. Kada se govori o molekulama, znamo da su \"ispod\" atomi, ali nas u datom kontekstu to ne zanima! Kontekst predstavlja skup okolnosti i činjenica, još jedna vrlo bitna stvar kada se govori o apstrakcijama. U matematici imamo apstrakciju broja. Kada kažemo broj obično mislimo na cijeli broj. Ali ne kažemo koji broj!? Dakle, samo znamo da mislimo na neki broj. Programi Da ponovimo, program je niz naredbi koje računar treba izvršiti, u cilju dobijanja nekog rezultata. Kako svi ljudi razmišljaju na sebi svojstven način, postoji teoretski beskonačno mnogo rješenja (programa) za jedan te isti problem! Programi često komuniciraju i sa \"vanjskim svijetom\". Npr. ako trebamo učitati neki tekstualni fajl i prebrojati sve riječi, taj fajl nije dio programa već je ulaz (en. input) u naš program. Isto vrijedi i za klik miša, unos sa tastature, mikrofona i sl. Kada želimo ispisati nešto na ekran, pustiti muziku na zvučnik, to se zove izlaz (en. output) iz našeg programa. Naravno, da ne bismo \"izmišljali toplu vodu\" možemo se okoristiti znanjem stečenim kroz ljudsku historiju. Ljudi su nadošli na koncept algoritma, koji predstavlja nedvosmislenu specifikaciju za rješavanje nekog problema. Tj. algoritam je niz precizno definisanih koraka za dobijanje nekog rezultata. Laički rečeno, to je recept za implementaciju neke funkcije. U toku pisanja koda nekog programa često će nam se pojavljivati greške. Tj. program se izvršava ali ne radi kako bismo željeli. Te greške se nazivaju bagovi (en. bug - buba, insekt). Za program koji ima takve greške kaže se da je bagovit. Proces u kojem tražimo greške i ispravljamo ih naziva se debagovanje.","title":"Untitled","url":"/programming/philosophy.html"},{"text":"Uvod u Scalu Scala je prije svega potpuno objektno orijentisan jezik. To znači da su sve vrijednosti u programu objekti, čak i brojevi i karakteri! Ovo nije slučaj u Javi, gdje imamo 7 \"primitivnih tipova\" kao što su int, char, boolean... U Scali su oni predstavljeni klasama Int, Char, Boolean... U C# je sličan slučaj kao i u Scali, gdje je int samo alijas za Int32, ali je i dalje klasa. Ovaj koncept se naziva i \"unified types\". Da pogledamo deklaraciju konstante: val x: Int = 5\n Tip se piše nakon naziva varijable, kao u Pascalu. U većini slučajeva kompajler nam može pomoći s \"zaključivanjem tipa\" (type inference). Kompajler će skontat za nas da je to broj! Tako da je prethodni primjer ekvivalentan sljedećem: val x = 5\n Primijetite i to da tačkazarez nije potrebna! Napokon!!! Izgleda da su pisci kompajlera vrlo lijeni ljudi... :D S razlogom, naravno. Ključna riječ val (skraćeno od value) označava konstantu, isto kao final u Javi: final int x = 5;\n Naravno, sljedeći kod se neće iskompajlirati. Dobićemo grešku \"reassignment to val\". val x = 5\nx = 6\n Da vidimo sada dobru staru varijablu, koja se deklariše s var, logično: var y = 5\ny = 6\ny += 3\n Varijabla y na kraju ima vrijednost 9. U Scali imamo još jednu vrstu varijable, tzv. \"lijena konstanta\" (lazy value): lazy val z = 5\n Vrijednost lazy val će se izračunati samo jednom, i to tek kada se pozove u programu! Npr. ako z poziva neku funkciju koja sadrži println, ispisaće se na ekran tek kada pozovemo z (tj. evaluiraće se funkcija). Ovaj koncept je poznat iz FP, vrlo je koristan za keširanje vrijednosti.","title":"Uvod u Scalu","url":"/scala/basics.html"},{"text":"","title":"Untitled","url":"/search/results.html"},{"text":"Klase Recimo da imamo zadatak da napravimo program za praćenje učenika u razredu. Za svakog učenika moramo unijeti ime, prezime i prosječnu ocjenu. Trebamo ispisati sve ove podatke i na kraju naći prosjek ocjena u razredu. Kako bismo ovo uradili sa do sada naučenim konceptima? Imena možemo staviti npr. u niz String[] imena. Prezimena možemo staviti npr. u niz String[] prezimena. Ocjene ćemo staviti npr. u niz double[] prosjeci. String[] imena;\nString[] prezimena;\ndouble[] prosjeci;\n\ndouble zbirProsjeka = 0;\nfor(int i = 0; i < imena.length; i ++) {\n    System.out.print(\"Učenik: \" + prezimena[i] + \" \" + imena[i]);\n    System.out.println(\", prosjek: \" + prosjeci[i]);\n    zbirProsjeka += prosjeci[i];\n}\ndouble prosjekRazreda = zbirProsjeka / imena.length;\nSystem.out.println(\"Ukupan prosjek razreda: \" + prosjekRazreda);\n Iako ovaj kod radi kako treba, nekako se ne osjećamo dobro zbog njega... Indeksi pršte na sve strane, šta ako je jedan od nizova kraći itd? Također, ovi nizovi nam uopće ne govore da su dio jedne cjeline. Neko ko čita ovaj kod mora se dobro zapitati šta oni predstavljaju. To je možda lahko na ovom (namjerno) malom primjeru, ali u projektima s milionima linija koda, niko nema vremena da \"razbija glavu\"... :) Ovo je jedan od razloga zašto se uvodi apstrakcija klase. Klasa je recept za pravljenje objekta. Kaže se još i da je objekat instanca klase. Objekat je obično skup primitivnih varijabli i drugih objekata. Dakle, koristi se za logičko grupisanje vrijednosti. U prethodnom primjeru trebali bismo grupisati ime, prezime i prosjek. Ova nova apstrakcija tj. klasa bi se zvala Ucenik. To bi izgledalo ovako: class Ucenik {\n    String ime;\n    String prezime;\n    double prosjek;\n}\n Kreiranje objekta Da bismo kreirali novi objekat klase Ucenik, koristimo operator new: Ucenik ucenik = new Ucenik();\n Ovaj operator naziva se konstruktor. Konstruktor je specijalna funkcija koja kreira novi objekat i vrati nam referencu na njega. Kompajler nam automatski kreira konstruktor za nas, kasnije ćemo vidjeti kako sami možemo definisati konstruktor(e). Polja klase Vrijednosti unutar klase nazivaju se polja klase/atributi (en. fields, properties), u ovom slučaju to su ime, prezime i prosjek. Pošto im nismo dodijelili nikakve početne vrijednosti, Java će ih postaviti na defaultne vrijednosti: referentne na null brojevne primitivne na 0 boolean primitivne na false Dakle, u ovom trenutku, ime ima vrijednost null, prezime ima vrijednost null, prosjek vrijednost 0. Idemo im dati neke smislene vrijednosti: ucenik.ime = \"Mujo\";\nucenik.prezime = \"Mujanović\";\nucenik.prosjek = 4.3D;\n Odabir polja se piše navođenjem reference, pa tačka, a zatim naziv polja. Dok nismo zaboravili, prethodni primjer sada izgleda puno bolje i razumljivije: Ucenik[] ucenici;\ndouble zbirProsjeka = 0;\nfor(Ucenik u : ucenici) {\n    System.out.print(\"Učenik: \" + u.prezime + \" \" + u.ime);\n    System.out.println(\", prosjek: \" + u.prosjek);\n    zbirProsjeka += u.prosjek;\n}\ndouble prosjekRazreda = zbirProsjeka / ucenici.length;\nSystem.out.println(\"Ukupan prosjek razreda: \" + prosjekRazreda);","title":"Klase","url":"/java/classes.html"},{"text":"Instalacija Jave Ako vam je baš mrsko instalirati Javu, postoje i online alternative: JDoodle JShell Zgodne su za probavanje i igranje sa Javom. Preporučujem da instalirate Javu 21 (ili noviju verziju). Samo downloadujte i raspakujte zip npr. u C:\\Java. Idući korak je dodavanje PATH varijable. Instalacija Jave 8 je malo komplikovanija, ali je dostupna i za 32-bitne i 64-bitne računare. Naravno, možete instalirati više verzija Jave, ali samo jednu možete dodati u PATH! Kada se otvori stranica sa prethodne slike kliknite na dugme download JDK. JDK (Java Development Kit) su alati za razvijanje Java programa: kompajler, debager itd. JDK sadrži JRE (Java Runtime Environment) koji služi za pokretanje Java programa (JVM, Java API klase itd). Na sljedećoj slici kliknite na \"jdk-8u131-windows-x64.exe\". To je instalacija za 64-bitni Windows. Ako slučajno imate 32-bitni Windows (vrlo malo vjerovatno) onda skinite tu verziju... Preporučujem da Javu instalirate u folder pod nazivom C:\\Java. Ovo ne morate raditi ali je korisno kada vam treba više verzija Jave. Također, neki programi na Windowsu imaju problema kada putanja sadrži razmak, zato nećemo instalirati u Program Files... Napomena: Ne trebate instalirati i JRE! Kada vam dođe prozor za JRE kliknite Cancel! (iksić). Upravo sam vam uštedio 100-tinjak megabajta, nema na čemu... :D Dakle, kada se završi download, otvorite instalaciju i kliknite Next. Zatim kliknite dugme \"Change...\" i prepravite putanju foldera na C:\\Java\\jdk1.8.0_131. JRE će već biti instaliran zajedno sa JDK! Tako da nam ne treba još jedna instalacija... Dodavanje PATH varijabli Dio koji slijedi vezan je više za sam rad operativnog sistema (Windows u našem slučaju) nego za Javu. Otvorite Computer Properties na Windowsu (desni klik na My Computer -> Properties). Otvoriće vam se sljedeći prozor: Kliknite na Advanced System Settings. Dobićete sljedeći prozor: Otvorite Advanced tab i kliknite Environment Variables.... Dodajte 3 sistemske varijable u donji prozor (u System Variables): Naziv varijable Vrijednost JAVA_HOME C:\\Java\\jdk1.8.0_131 JDK_HOME %JAVA_HOME% JRE_HOME %JAVA_HOME%\\jre Glavno, otvorite PATH varijablu i dodajte ;%JAVA_HOME%\\bin na kraj. Nemojte zaboravit tačkazarez kopirati! :D Bez navodnika, naravno! Kliknite Ok, Ok... To je to! Uspješno ste instalirali Javu! :) Stanje bi trebalo biti otprilike ovako: Provjera instalacije Da bi provjerili jesmo li uspješno obavili zadatak, otvorićemo Command Prompt (kod Linuxaša se rekne Shell). Otvorite Start, ukucajte cmd i kliknite Enter. Ukucajte java -version. Ako dobijete poruku 'java' is not recognized as an internal or external command, operable program or batch file. nešto nije uredu, provjerite sve korake sekcije \"Dodavanje PATH varijabli\" ponovo! Ako dobijete nešto slično sljedećoj slici, sve je OK:","title":"Instalacija Jave","url":"/java/installation.html"},{"text":"Osnove Jave JShell Da bi se igrali sa JShellom morate imati instaliranu Javu verzije 9 ili više. Ispratite sekciju za instalaciju. Koristićemo JShell program za upoznavanje i igranje s Java jezikom. Otvorite konzolu (bez ikakvog straha! :D), ukucajte jshell i udarite Enter. Dobićete tzv. interaktivni shell u kojem možete kucati Javu. Zovu ga još i REPL (Read Evaluate Print Loop), jer dobija unos od nas, evaluira ga, isprinta neki odgovor, i ponavlja ukrug. Izrazi i operatori Za početak, JShell možemo koristiti kao primitivni kalkulator. Tako ćemo steći osjećaj kako se ponašaju brojevi u Javi, i usput objasniti neke osnovne koncepte i pojmove. Ako ukucamo u REPL broj 5 i pritisnemo Enter, vidjećemo sljedeće: jshell> 5\n$1 ==> 5\n REPL je razumio i odgovorio nam da je to vrijednost 5. U programiranju se kaže da je broj izraz. Izraz u programiranju ima isto značenje kao i u matematici. Dakle, misli se na nešto što ima vrijednost. Nešto što možemo prikazati, s čim možemo baratati. Ako se opet prisjetimo (dosadne) matematike, sjetićemo se da se simboli +, -, *, itd. nazivaju operatori. Pošto smo rekli da je REPL kao kalkulator, da vidimo šta sve možemo uraditi: jshell> 2 + 2\n$2 ==> 4\njshell> 2 - 5\n$3 ==> -3\njshell> 7 * 3\n$4 ==> 21\njshell> 9 / 4\n$5 ==> 2\n Izgleda da dijeljenje ne radi kako treba... Našli smo grešku! :D Ali, nije tako. Java podrazumijeva da želimo podijeliti dva cijela broja! Ako se sjetimo osnovne škole, 5 / 2 je ustvari 2 cijelih i ostatak 1. :) Dakle, kada dijelimo dva cijela broja, ustvari radimo \"cjelobrojno dijeljenje\". Također, možemo dobiti i ostatak od dijeljenja, pomoću operatora %. Npr. 5 % 2 je 1. Kada želimo koristiti realne brojeve (sa zarezom), pišemo tačku nakon broja. Tačka se koristi umjesto zareza, jer se zarez koristi za neke druge stvari. Uglavnom, da vidimo kako rade realni brojevi (en. floating point): jshell> 3.0 + 5.1\n$6 ==> 8.1\njshell> 7.3 - 2.9\n$7 ==> 4.4\njshell> 5.5 * -2.0\n$8 ==> -11.0\njshell> 9.0 / 4.0\n$9 ==> 2.25\n Sada se sve čini onako kako treba. :) Redoslijed operacija (en. precedence) radi očekivano. Npr. množenje se radi prije sabiranja. Ako želimo baš, baš, biti sigurni da će program raditi kako treba, možemo koristiti zagrade. jshell> 2 + 2 * 2\n$10 ==> 6\njshell> (2 + 2) * 2\n$11 ==> 8\n Varijable Primijetite šta REPL ispisuje kao odgovor, poslije svake unesene linije: $1 ==> 5. Ako ukucamo $1 u REPL vidjećemo sljedeće: jshell> $1\n$1 ==> 5\n Dakle, REPL nam kaže da je vrijednost varijable $1 jednaka 5. Izraz 5 je spremljen u varijablu $1, koju možemo koristiti umjesto broja 5. Šta je to varijabla? Zamislite da imate kutije raznih oblika i dimenzija. Varijabla je baš kao kutija sa natpisom koji vi želite. Npr. kutija u kojoj čuvamo neki broj. Kreiraćemo novu varijablu pod nazivom brojJabuka, za čuvanje integera (en. \"integer\" je cijeli broj). Ovo int je tip varijable (veličina i oblik kutije)! Kasnije ćemo govoriti malo detaljnije o tipovima. jshell> int brojJabuka;\nbrojJabuka ==> 0\ncreated variable brojJabuka : int\n Pošto nismo dali vrijednost našoj varijabli, Java nam pomaže tako što postavlja brojJabuka na vrijednost 0. Obično je to ono što želimo, ali je najbolje postaviti početnu vrijednost eksplicitno, čim uvodimo novu varijablu. Tako odmah znamo koja joj je početna vrijednost i ne moramo razmišljati o tome... :) To radimo ovako: jshell> int brojJabuka = 0;\nbrojJabuka ==> 0\ncreated variable brojJabuka : int\n Vrlo jednostavno, nakon naziva varijable slijedi znak jednako i vrijednost, ovdje je to 0. Primijetite da ovaj znak jednakosti nije matematička jednakost već operacija dodjele! Tj. kao da kažemo \"postavi varijablu brojJabuka na nulu!\". Varijablu možemo izmijeniti, tj. postaviti na novu vrijednost: jshell> brojJabuka = 5;\nbrojJabuka ==> 5\nassigned to brojJabuka : int\n Sada je vrijednost promijenjena na 5. Nakon ove linije, gdje god koristimo brojJabuka to je kao da napišemo 5. Također, možemo iskoristiti prethodnu vrijednost varijable da bismo dobili novu: jshell> brojJabuka = brojJabuka + 1;\nbrojJabuka ==> 6\njshell> brojJabuka += 1;\n$23 ==> 7\n U izrazu brojJabuka + 1, vrijednost brojJabuka odnosi se na zadnju vrijednost varijable, dakle vrijednost prije ove linije, tj. 5. Postoji i skraćena verzija za ovo, prikazana na liniji 3, s operatorom +=. Također imaju skraćene verzije i za oduzimanje, množenje, dijeljenje i modulo: -=, *=, /=, %= respektivno. Ovo \"respektivno\" je fancy izraz za \"u navedenom redoslijedu\". :D Nazivi varijabli Nazivi varijabli i tipova (en. identifiers) ne mogu imati razmake u sebi, ne mogu biti nijedna od rezervisanih riječi kao što je class, int. Ne mogu biti neki rezervisani znakovi, kao npr. ,, & itd. Ne mogu počinjati brojem. Primjeri nevalidnih naziva varijabli (isprobajte u JShellu): int my variable = 5 int int = 5 int , = 5 int 5something = 5 Primjeri validnih naziva varijabli: int _abc = 5 int $xyz = 5 int Z = 5 int t$df_x = 5 Mogu se koristiti simboli _ i $ ali ih treba izbjegavati, pogotovo kao prvo slovo u nazivu varijable! Preporučeno je da varijable počinju malim slovom, da su camelCase (svaka iduća riječ počinje velikim slovom), npr. myVariable. Konstante (varijable koje se ne mogu mijenjati) se pišu velikim slovima i riječi su razdvojene donjom crticom, npr. MY_CONST.","title":"Osnove Jave","url":"/java/basics.html"},{"text":"While petlja Kada želimo ponavljati izvršiti neki dio koda više puta, najjednostavniji način je copy-paste. Kopiramo ga n-puta i završeno! :D Međutim, ovo nije fleksibilno kada kasnije želimo da izmijenimo taj djelić koda. Tada moramo izmijeniti sve linije... :/ Zato postoje specijalne naredbe za ponavljanje: while, do-while i for. Zovu se još i \"petlje\", jer se vrlo lahko zapetljati u njima. U sljedećem primjeru želimo izvršavati kod sve dok je neki uslov ispunjen (en. while je \"dok\"). int i = 0;\nwhile(i < 10) {\n    System.out.println(\"Cifra i je: \" + i);\n    i = i + 1;\n}\n Naravno, unutar tog bloka uslov se mora mijenjati, inače se program neće nikad zaustaviti. To se naziva beskonačna petlja i obično nije poželjna... :) Uslov se ispituje u svakoj iteraciji petlje. Dakle, svaki put kada se dođe do linije 5 uslov će se ponovo ispitati. Ako uslov nije zadovoljen, petlja se zaustavlja i program se nastavlja izvršavati na liniji 6.","title":"While petlja","url":"/java/while.html"},{"text":"Hello World! Vjerovatno vam je do sada dodijao JShell i kucanje u konzoli... :D Sada ćemo vidjeti kako se ustvari pokreću Java programi. Sastoji se iz 2 dijela: kompajliranje i pokretanje (en. run). Napomena: ovaj dio nije obavezan, ali pomaže za razumijevanje procesa. Možete preskočiti na sekciju Implementacija ako želite. Kompajler (en. compiler) je program koji provjerava sintaksu našeg programa, da li se poklapaju tipovi itd. te nam prijavljuje greške ako ih pronađe. I to sve prije nego smo i pokrenuli naš program! Predobro! :D Tako smo sigurni da se bar neke greške neće pojaviti u programu. Javin kompajler se zove javac (skraćeno od Java compiler). Ulaz u kompajler je izvorni tekst programa (en. source code) koji smo napisali (obični tekstualni fajlovi s nastavkom .java ), a izlaz su fajlovi koji sadrže izvršni kod, koji se može pokrenuti nekako, izvršiti (to su .class fajlovi). Idući korak je pokretanje programa. Java programi se sastoje od bytecode naredbi (kod nezavisan od procesora i operativnog sistema), koje su vrlo slične mašinskom kodu (specifičnom za svaki procesor). Izlaz iz kompajlera, .class fajlovi sadrže te bytecode naredbe, i njih izvršava tzv. JVM (Java Virtuelna Mašina). JVM je ustvari java program. Implementacija Da vidimo napokon kako izgleda obavezni \"Hello World\" primjer: class HelloWorldApp {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n    }\n}\n Kada se pokrene prethodno prikazani program dobićemo sljedeći rezultat u konzoli: Hello World!\n Kompajliranje i pokretanje programa Sadržaj programa sačuvajte u fajl HelloWorldApp.java. Primijetite da se mora zvati isto kao i klasa, s nastavkom .java! Kod mene se ovo sve nalazi u folderu C:\\programiranje. Kucamo sljedeće: C:\\programiranje> javac HelloWorldApp.java\nC:\\programiranje> java HelloWorldApp\nHello World!\n To je to, sada možemo nastaviti dalje. Svaki primjer koji budemo radili možete isprobati, nemojte mi slijepo vjerovati na riječ da fercera. :) Komentari Komentari su tekst koji ne utiče na rezultat programa. Koriste se samo radi objašnjavanja koda, nekom drugom ili nama kad budemo čitali kasnije. Prva vrsta komentara se piše sa 2 kose crte // (en. slash) i vrijedi do kraja linije. Druga vrsta je višelinijska (en. multiline) i počinje s /* a završava s */. Npr: // komentar1\n    \n/*\n    * komentar2\n    */\n\nclass HelloWorldApp {\n    ...","title":"Hello World!","url":"/java/hello-world.html"},{"text":"For petlja Java ima i tzv. for petlje. To su haman-ha while petlje s finijom sintaksom. Sljedeći primjer radi isto kao i prethodni sa while petljom. for (int i = 0; i < 10; i = i + 1) {\n    System.out.println(\"Cifra i je: \" + i);\n}\n Uopćena sintaksa for petlje je sljedeća: for(inicijalizacije; uslov; koraci). Dijelovi for petlje su razdvojeni tačkazarezom. Umjesto da deklarišemo varijable prije petlje, zgodno je deklarisati ih u sklopu petlje, jer nam poslije petlje one ne trebaju. Za to nam služi dio inicijalizacije. Dio uslov je isti kao i kod while petlje. Dio koraci dolazi na kraju petlje, isto kao linija 4 u našoj while petlji. Koraci obično utiču na uslov za izlaz iz petlje.","title":"For petlja","url":"/java/for.html"},{"text":"Nizovi Kada trebamo zapamtiti više vrijednosti istog tipa, to radimo pomoću niza (en. array). Tip niza se piše kao tip[]. Ovo \"tip\" može biti int, String ili bilo šta drugo. Uglate zagrade kažu da se radi o nizu, a ne \"običnom\" tipu. Kada kreiramo niz, kažemo new tip[velicina], gdje je velicina neki broj, mora biti int. Dužina niza je fiksna, ne može se promijeniti! Kada pristupamo elementu niza, to radimo preko indeksa, tj. rednog broja u nizu. Prvi element ima indeks 0, drugi ima indeks 1 itd. Npr. da bi izmijenili prvi element pišemo niz[0] = 9;. Ovdje nam odmah naumpadaju petlje koje smo naučili, while i for koje su vrlo korisne pri radu s nizovima. Ako želimo npr. spremiti ocjene studenta, za to možemo koristiti niz. Recimo da student ima 12 predmeta. int[] ocjene; // nije još inicijaliziran, ne bi ga trebali koristiti!\nocjene = new int[12]; // niz od 12 nula (po defaultu se popuni nulama)\n\nocjene[0] = 9;\n\nfor(int i = 0; i < 12; i++) {\n    System.out.println(ocjene[i]);\n}\n Vidimo da se 12 ponavlja na 2 mjesta, i označava istu stvar, dužinu niza. Naravno, to nije dobra praksa, jer ako trebamo promijeniti dužinu niza, to moramo odraditi na više mjesta. Možemo napraviti novu varijablu u koju ćemo spremiti dužinu niza. Npr. int BR_OCJENA = 12; i onda koristiti nju umjesto literala 12. Ovako je kod puno fleksibilniji. Međutim, ne znamo uvijek dužinu niza unaprijed. Šta ako pravimo funkciju koja prima niz? Da proslijedimo uvijek i dužinu niza? To bi bilo vrlo nečitljivo i dosadno. Srećom, nizovi u Javi imaju polje (en. property) koje sadrži dužinu niza i zove se length. Kada kažemo ocjene.length dobićemo dužinu niza. :) Tako da smo u primjeru mogli/trebali napisati for(int i = 0; i < ocjene.length; i++). Postoji još jedan zgodan način za inicijalizaciju niza. Ako znamo unaprijed šta niz sadrži, možemo odmah dodijeliti te vrijednosti nizu. Pritome ne moramo ni navoditi dužinu niza, jer će nam kompajler pomoći. Kad smo već kod \"zgoda\", imamo i tzv. \"poboljšanu for petlju\" (en. enhanced for loop). Zove se još i \"for-each\" petlja. Ona se koristi kada želimo da prođemo kroz sve elemente niza. Ako nam treba i indeks onda moramo koristiti običnu for petlju... // array literal\nString[] gradovi = { \"Sarajevo\", \"Tuzla\", \"Mostar\" };\n\n// enhanced for loop\nfor(String grad: gradovi) {\n    System.out.println(grad);\n}\n Višedimenzionalni nizovi Možemo imati i niz nizova, niz nizova nizova itd. Ne postoji ograničenje na dubinu u koju idemo. Nizovi sa 2 ili više dimenzija nazivaju se \"višedimenzionalni\" (en. multidimensional). Dvodimenzionalni nizovi se zovu još i \"matrice\" (en. matrix). Matrice se često koriste u igricama i matematičkim programima. Npr. kad trebamo predstaviti stanje šahovske ploče i sl. to možemo uraditi sa matricom. Ugniježdeni nizovi ne moraju imati istu dužinu. Recimo da imamo zgradu sa različitim brojem stanova po spratu. Svaki red predstavlja jedan sprat, i u svakom spratu imamo br. stanara za svaki stan. Trebamo ispisati koliko koji sprat ima ukupno stanara: int[][] brStanaraPoStanovima = { \n    { 1, 2, 3, 4 }, // prvi sprat\n    { 5, 6, 2 }     // drugi sprat\n};\n\nfor (int i = 0; i < brStanaraPoStanovima.length; ++i) {\n    int brStanaraSprata = 0;\n    for(int j = 0; j < brStanaraPoStanovima[i].length; ++j) {\n        brStanaraSprata += brStanaraPoStanovima[i][j];\n    }\n    System.out.println(\"Br. stanara sprata \" + i + \" je: \" + brStanaraSprata);\n}\n Rezultat: Br. stanara sprata 0 je: 10\nBr. stanara sprata 1 je: 13","title":"Nizovi","url":"/java/arrays.html"},{"text":"Tipovi Većina ozbiljnih jezika ima tipove. One koji nemaju slobodno izbjegavajte! 😉 Tip je apstrakcija koju dati p.j. razumije. Npr. kada napišemo int broj, ovo \"int\" je tip varijable \"broj\". Tako će kompjuter znati, između ostalog, koliko memorije da rezerviše za tu varijablu. Pošto smo mu dali tu informaciju, onda nam može i ukazati na greške u programu koji pišemo. Npr. da ne možemo sabirati broj i slovo, kruške i jabuke... Također nas može i usmjeriti, npr. reći nam koje su operacije dostupne nad datim tipom, da ne moramo nagađati. Da vidimo JShell u akciji: jshell> int broj = 6;\nbroj ==> 6\njshell> broj = 4.5;\nError:\nincompatible types: possible lossy conversion from double to int\nbroj = 4.5;\n^-^\n Dakle, Java nam ne da da dodijelimo broj 4.5 varijabli koja je tipa int (cijeli broj). To ima smisla itekako, jer bismo izgubili ovo \"zarez pet\"... :) Ako želimo da budemo pametniji od Jave, i da na silu \"utrpamo\" 4.5 u int to ide ovako: jshell> broj = (int) 4.5;\nbroj ==> 4\n I šta smo dobili? Samo cijeli dio... Ali, nekad nam ovo baš i treba! Uglavnom, pouka je da trebamo slušati šta nam Java poručuje! To radi za naše dobro, nju nije briga ako je rezultat netačan, ako je to ono što želimo... :D Naravno, imamo još puno toga reći o tipovima, tek smo \"zagrebali površinu\"! Npr. kako da grupišemo podatke? Kompleksni brojevi, podaci o ljudima, proizvodima itd? O tom ćemo pričati u poglavlju o klasama. :) Stringovi i karakteri Prije nego nastavimo dalje, moramo objasniti i stringove, jer se vrlo često koriste. String (iz en. nit, kanafa) koristi se za predstavljanje teksta, tj. niza karaktera. Karakter (en. character je simbol) označava jedan simbol, bio to broj, slovo ili neki simbol, emoji... Stringovi se pišu s dvostrukim navodnicima: jshell> \"Poyy sviete!\"\n$1 ==> \"Poyy sviete!\"\n Stringovi se tretiraju specijalno u Javi, pa imamo i operator \"sabiranja\" nad njima. Npr. možemo \"sabrati\" 2 stringa, string s brojem i sl: jshell> \"Ime\" + \"Prezime\"\n$2 ==> \"ImePrezime\"\njshell> \"x je \" + 5\n$3 ==> \"x je 5\"\njshell> \"x je \" + 5 + \", i kad se pomnoži s \" + 3 + \" daje \" + (5*3)\n$4 ==> \"x je 5, i kad se pomnoži s 3 daje 15\"\njshell> \"strin\" + 'g'\n$5 ==> \"string\"\njshell> String s = \"ABC\"\ns ==> \"ABC\"\n Ovo sabiranje se naziva konkatenacija (en. concatenate je nadovezati/spojiti/naštiklati). Radi dvosmjerno, možemo sabrati i broj sa stringom, npr. 5 + \"hepek.abc\". String se piše s velikim početnim slovom! String u pozadini koristi charactere. Kao što smo već rekli, char je samo jedan karakter. Piše se s jednostrukim navodnicima: jshell> 'a'\n$9 ==> 'a'\n\njshell> ''\nError:\nempty character literal\n''\n^\n        'ab'\nError:\nunclosed character literal\n'ab'\n^\n\njshell> char slovoA = 'A'\nslovoA ==> 'A'\n Dakle, karakter ne može biti prazan, niti može sadržati više karaktera. Za ove namjene koristi se String! :) Važne napomene: string \"1\" nije isto kao broj 1 karakter '1' nije isto kao broj 1 string \"1\" nije isto kao karakter '1' postoje posebne funkcije za pretvaranje iz jednog tipa u drugi","title":"Tipovi","url":"/java/types.html"},{"text":"Funkcije Prvo malo terminologije. Potprogram (en. subprogram, subroutine, procedure) je dio programa koji možemo pozvati po imenu. Java ih zove... khm... metode... :D Ja ću najčešće koristiti termin \"funkcija\" ili \"metoda\", kako kad. Funkcijama se mogu proslijediti argumenti, tj. ulazni podaci koje funkcija može koristiti. Slijedi primjer funkcije za sabiranje dva cijela broja: int suma(int a, int b) {\n    return a + b;\n}\n Definicija funkcije ima sljedeće dijelove: tip vrijednosti koju vraća funkcija. Kod nas je to int, jer je rezultat sabiranja dva inta također int. naziv funkcije, kod nas je to \"suma\" lista parametara u zagradama, ovdje su to brojevi: int a, int b. Ako nema parametara onda idu samo zagrade, npr. mojaFunkcija() tijelo funkcije u vitičastim zagradama ključna riječ return i rezultat funkcije Da vidimo u JShellu kako da deklarišemo i pozovemo prethodnu funkciju: jshell> int suma(int a, int b) {\n    return a + b;\n}\ncreated method suma(int,int)\njshell> suma(1, 4)\n$6 ==> 5\n Funkcija se poziva navođenjem njenog imena, i argumenata unutar zagrada. Npr. suma(1, 4). Pošto poziv funkcije vraća vrijednost int, možemo je spasiti u varijablu, npr. int rezultat = suma(1, 4). Dakle, i poziv funkcije je izraz! Čim ga možemo dodijeliti varijabli. :)","title":"Funkcije","url":"/java/functions.html"},{"text":"Naredbe Naredbe (en. statements) su kao rečenice u govornom jeziku, i obično su u imperativnom obliku, kao da se obraćamo kompjuteru: uradi ovo, izbriši ono, upiši u fajl itd. Deklaracije varijabli su naredbe, npr. int i = 5;, može se čitati kao \"napravi varijablu s imenom 'i' i dodijeli joj vrijednost 5! ODMAH!\". Iako još nismo objasnili funkcije, neke od njih su također naredbe, npr: jshell> System.out.println(\"Hello!\")\nHello!\n Vrlo duga naredba System.out.println je funkcija za printanje u konzolu. Do sada je JShell to automatski radio za nas, ispisivao vrijednost zadnjeg izraza, u svom nekom predefinisanom formatu... Ovako mi možemo ispisati šta god želimo. Primijetite da ispisani String nema navodnika! Navodnici se samo koriste za pisanje stringova!!! Nisu uključeni u samu vrijednost stringa. Isto je i sa karakterima. Da vidimo još par primjera: jshell> System.out.println(\"x je \" + 5);\nx je 5\n\njshell> String rezultat = \"x je \" + 5;\nrezultat ==> \"x je 5\"\njshell> System.out.println(rezultat);\nx je 5\n Dakle, možemo proslijediti string direktno, ili varijablu koja je string, svejedno. 🙂 Kraj naredbe se označava s ; (tačkazarez, en. semicolon).","title":"Naredbe","url":"/java/statements.html"},{"text":"Uslovno grananje Kompjuteri obično izvršavaju naredbe jednu nakon druge tj. sekvencijalno. Međutim, potrebne su nam i naredbe za uslovno grananje. To jest, kada želimo izvršiti nešto samo pod datim uslovima. U Javi za ovu svrhu imamo 2 naredbe: if i switch. If naredba Grananje pomoću if naredbe je vrlo jednostavno. Ako je uslov ispunjen onda će se taj dio koda izvršiti. U suprotnom program nastavlja dalje. Ovo \"uslov ispunjen\" može biti DA ili NE, tj. ISTINA (en. true) ili NEISTINA (en. false). Ovaj tip podatka se naziva Boolean po matematičaru George Boole-u. Ako se sjećate logike iz matematike, tablica istine, \"I\", \"ILI\", \"NE\" i ostalih, TO JE TO! :D Logička operacija \"I\" (en. and) se u Javi piše sa && Logička operacija \"ILI\" (en. or) se u Javi piše sa || Logička operacija \"NE\" (en. negate, not) se u Javi piše sa !, i piše se prije uslova koji negira, npr. !small. Primjer: double temperatura = -3;\nboolean uslovHladno = temperatura < 5;\nif (uslovHladno) {  // može i \"if(temperatura < 5)\"\n    System.out.println(\"Obuci se, studeno je pravo!\");\n}\nSystem.out.println(\"Temperatura je: \" + temperatura);\n Navedeni primjer ispisaće sljedeće: Obuci se, studeno je pravo!\nTemperatura je: -3\n Ako izmijenimo temperaturu na 20, vidjećemo da se prvi println neće izvršiti, jer uslov nije ispunjen: Temperatura je: 20\n Da vidimo još jedan primjer: double temperatura = 21.33;\nboolean uslovToplo = temperatura > 25;\nif (uslovToplo) // može i \"if(temperatura > 25)\"\n    System.out.println(\"Toplo je\");\nelse\n    System.out.println(\"Nije toplo\");\n Prethodni kod će ispisati \"Nije toplo\", jer uslov uslovToplo nije ispunjen, tj. izraz 21.33 > 25 je false. Ovo if else se tretira kao jedna naredba! Ako želimo da izvršimo više od jedne naredbe u if ili else bloku, samo ih okružimo zagradama: if (uslov) { naredbe1... } else { naredbe2... }. Nakon linije 6 program nastavlja normalno sa svojim izvršenjem. Možemo imati i više uslova u jednoj naredbi, tj. niz if-elseif-elseif-...-else. Ovi uslovi bi trebali biti međusobno isključivi tj. smisleni. Ako napišete if (broj>5) { } else if (broj>7) { } to nema puno smisla jer ako broj nije veći od 5, ne može biti veći od 7, nema šansone. :D Ako jeste veći od 5, biće izvršen prvi blok, ali drugi blok koda NIKAD NEĆE BITI IZVRŠEN! Ako postoji grana else, ona će biti izvršena ako nijedan uslov nije ispunjen. Ako ne postoji else i nijedan uslov nije ispunjen, ništa neće biti izvršeno od te cijele if naredbe. Switch naredba Grananje pomoću switch naredbe može učiniti kod dosta preglednijim. Ova naredba se koristi umjesto mnoštva if-else grana, od koje svaka grana provjerava je li varijabla jednaka nekoj vrijednosti. U Javi možete \"switchati\" cijele brojeve, karaktere, stringove i enumeracije. int i = 5;\nswitch (i) {\n    case 3:\n        System.out.println(\"Tri\");\n        break;\n    case 5:\n        System.out.println(\"Pet\");\n        break;\n    default:\n        System.out.println(\"Ne znam...\");\n        break;\n}\n Na liniji 2 ispituje se čemu je jednaka vrijednost varijable i, redom odozgo naravno. Prvi slučaj (en. case) koji bude ispunjen će biti izvršen. Ako je vrijednost varijable i broj 5, ispisaće se na ekran \"Pet\". Često ne znamo koliko ima mogućih slučajeva, pa onda trebamo odlučiti šta da uradimo po tom pitanju. Za to nam služi ključna riječ default. To je ustvari ona else grana u if naredbi! ;)","title":"Uslovno grananje","url":"/java/branching.html"},{"text":"Opseg Svaka varijabla/funkcija/klasa u Javi ima svoj opseg (en. scope). Scope je dio programa u kom je ta varijabla vidljiva tj. može se tu koristiti. Scope-ovi mogu biti ugniježdeni. Unutrašnji scope može vidjeti tj. koristiti varijable iz vanjskog scope. Unutrašnji scope može definisati novu varijablu koja se zove isto kao varijabla u vanjskom scope! Postoje dva najvažnija scope-a a to su: scope klase i scope metode. Scope metode je ugniježden u scope klase. Npr. polja klase se mogu koristiti u metodama, ali varijable definisane u metodi se ne mogu koristiti u klasi: class Abc {\n    int x = 5;\n    // int z = y + 2; // ovo nije dozvoljeno\n\n    void bla() {\n        int y = x + 1;\n    }\n    \n    void meh() {\n        int y = x + 3;\n    }\n}\n Na liniji 3. vidimo primjer nedozvoljene operacije. Ako se pitate zašto: Polja objekta se inicijalizuju čim se pozove konstruktor te klase. Metode se pozivaju na zahtjev tj. ručno, on-demand. Zato nam Java ne dozvoljava tu operaciju. Također, kompajler ne zna na koje y mislimo, da li ono iz bla() ili iz meh()... :) Primijetite i to da varijabla y iz bla() nema nikakve veze s varijablom y iz meh()!!! To su dva skroz nezavisna bloka, svaki ima svoj scope. Neki primjeri nedozvoljenog definisanja varijabli su dati u metodi ne(). Otkomentarišite liniju po liniju da vidite šta će vam kompajler reći. U metodi da() dati su neki primjeri dozvoljenog korištenja istoimenih varijabli. static void ne() {\n    int x = 1;\n    {\n        // int x = 1; // nope\n    }\n    \n    {\n        int y = 1;\n    }\n    // y++; // ne može se koristiti izvan bloka! (isto je i za if, for, while, switch)\n    \n    // for(int x = 1; x < 5; x++) { }  // x vec definisano na pocetku metode\n    \n    // while(true) { int x = 1; }      // x vec definisano na pocetku metode\n    \n    for(int i = 1; i < 5; i++) {\n        // for(int i = 1; i < 5; i++) {  } // i vec definisano u vanjskoj petlji\n    }  \n}\n\nint duzina;\nstatic void da() {\n\n    // zasjenjivanje polja (shadowing)\n    // pošto metoda ima svoj scope, \n    // dozvoljeno joj je uvesti novu varijablu istog imena kao polje klase\n    int duzina = 5;\n    \n    // različiti blokovi\n    {\n        String str = \"abc\";\n    }\n    {\n        String str = \"abc\"; // yep, nije na istom NIVOU\n    }\n    \n    // različite petlje/blokovi\n    for(int x = 1; x < 5; x++) { }\n    for(int x = 1; x < 5; x++) { } // fercera\n    \n}","title":"Opseg","url":"/java/scope.html"},{"text":"Tipovi, opet Rekli smo da ćemo nastaviti malo detaljnije o tipovima. Java ima 2 vrste tipova: primitivne i referentne. Primitivni tipovi Primitivnih tipova ima 8 i to su boolean, char, int, long, short, byte, double i float. Pišu se malim slovima. Ne možemo definisati nove primitivne tipove u Javi! Primitivni tipovi predstavljaju \"sirove podatke\", većina referentnih tipova ih koristi u pozadini. Referentni tipovi U referentne tipove ubrajaju se svi tipovi koji nisu primitivni. Ove tipove možemo definisati i mi sami. Konvencija je da se pišu velikim početnim slovom. Već smo vidjeli par primjera ovog tipa: String i nizovi. U nastavku ćemo vidjeti kako da definišemo klase, koje spadaju u referentne tipove. Reference Varijable koje imaju referentni tip nazivaju se reference. VRLO VAŽNO: Svaka referenca može imati vrijednost null!!! Primitivne varijable nikada ne mogu biti null. Vrijednost null je specijalna vrijednost. Ona označava da je varijabla \"prazna\", neupotrebljiva.","title":"Tipovi, opet","url":"/java/types2.html"},{"text":"Maths Nothing here yet.","title":"Maths","url":"/en/maths/index.html"},{"text":"These are my ramblings about programming.","title":"Programming","url":"/en/programming/index.html"},{"text":"Welcome!","title":"Home Page","url":"/en/index.html"},{"text":"FlowRun Kompjuteri izvršavaju naredbe jednu po jednu, redom. Naredbe su logički grupisane u programe. Program sadrži naredbe koje kompjuter treba izvršiti. Program se može predstaviti vizuelno pomoću dijagrama toka (engl. flowchart). Koristićemo ugrađeni editor, koji može i pokrenuti program koji napravimo. Ako želite da sačuvate svoje programe koje napravite, možete se registrovati na flowrun.io. Tu možete vidjeti i neke programe koje su napravili drugi korisnici, kliknite ovdje. Tutorijali: Osnove Varijable If naredba While petlja Do While petlja For petlja Ugrađene funkcije Definisanje funkcije Povratna vrijednost funkcije Rekurzivne funkcije","title":"FlowRun","url":"/flowrun/index.html"},{"text":"FlowRun Kompjuteri izvršavaju naredbe jednu po jednu, redom. Naredbe su logički grupisane u programe. Program sadrži naredbe koje kompjuter treba izvršiti. Program se može predstaviti vizuelno pomoću dijagrama toka (engl. flowchart). Koristićemo ugrađeni editor, koji može i pokrenuti program koji napravimo. Ako želite da sačuvate svoje programe koje napravite, možete se registrovati na flowrun.io. Tu možete vidjeti i neke programe koje su napravili drugi korisnici, kliknite ovdje. Tutorijali: Osnove Varijable If naredba While petlja Do While petlja For petlja Ugrađene funkcije Definisanje funkcije Povratna vrijednost funkcije Rekurzivne funkcije","title":"FlowRun","url":"/flowrun/index-2.html"},{"text":"Matematika Matematika je jedan od najomraženijih predmeta kod većine učenika. S pravom, dakako! Zapitajmo se šta je uzrok tome? Da li je matematika zaista toliko teška, komplikovana? Odgovor je jednostavan, naravno... da jeste. :D Ako ne razumijemo osnovne koncepte kao što su skupovi i funkcije, kako nastaviti dalje? Šta profesori rade po tom pitanju? Obično pišu knjige od po 1000+ stranica i nazivaju ih jednostavnim... Po mom skromnom mišljenju, većina koncepata nije dovoljno dobro ili nikako objašnjena. Npr, meni nikad nisu objašnjavali šta znače razni simboli tipa ∀\\forall∀, ∃\\exists∃ i →\\rightarrow→... To se smatra elementarnim i krivica se prebacuje ili na prethodnog profesora ili pak na mene jer sam glup pa to ne znam. Zar je sramota pitati takva pitanja? Hoćeš li ti biti manje profesor ako zastaneš 5 minuta i objasniš terminologiju? Lema, korolar, teorema, šta su te stvari??? :D Nauči me! To ti je pos'o! Sadržaj: Teorija skupova","title":"Matematika","url":"/maths/index.html"},{"text":"Programiranje Sadržaj: Filozofija programiranja Programerska terminologija Paradigme programiranja","title":"Programiranje","url":"/programming/index.html"},{"text":"Saketov blog Moje ime je Sakib, bujrum! :) Ovdje ćete pronaći tutorijale za programiranje i još ponešto. Ako ste totalni početnik, i želite naučiti programirati, preporučujem da počnete sa dijagramima toka. Dosta je lakše početi s vizuelnim programiranjem, jer praćenjem linija lakše je shvatiti kako program radi. Ovi tutorijali vode vas kroz osnovne gradivne dijelove programa. Nakon toga možete nastaviti s Java programskim jezikom. Tu ćete se upoznati sa jednim vrlo popularnim, traženim i plaćenim programskim jezikom. Vrlo je sličan drugim popularnim jezicima kao što su C#, JavaScript i ostali. Tako da ako se odlučite i za neki drugi jezik kasnije, neće vam biti teško da ga savladate.","title":"Početna stranica","url":"/index.html"},{"text":"Saketov blog Moje ime je Sakib, bujrum! :) Ovdje ćete pronaći tutorijale za programiranje i još ponešto. Ako ste totalni početnik, i želite naučiti programirati, preporučujem da počnete sa dijagramima toka. Dosta je lakše početi s vizuelnim programiranjem, jer praćenjem linija lakše je shvatiti kako program radi. Ovi tutorijali vode vas kroz osnovne gradivne dijelove programa. Nakon toga možete nastaviti s Java programskim jezikom. Tu ćete se upoznati sa jednim vrlo popularnim, traženim i plaćenim programskim jezikom. Vrlo je sličan drugim popularnim jezicima kao što su C#, JavaScript i ostali. Tako da ako se odlučite i za neki drugi jezik kasnije, neće vam biti teško da ga savladate.","title":"Početna stranica","url":"/index-2.html"},{"text":"Saketov blog Moje ime je Sakib, bujrum! :) Ovdje ćete pronaći tutorijale za programiranje i još ponešto. Ako ste totalni početnik, i želite naučiti programirati, preporučujem da počnete sa dijagramima toka. Dosta je lakše početi s vizuelnim programiranjem, jer praćenjem linija lakše je shvatiti kako program radi. Ovi tutorijali vode vas kroz osnovne gradivne dijelove programa. Nakon toga možete nastaviti s Java programskim jezikom. Tu ćete se upoznati sa jednim vrlo popularnim, traženim i plaćenim programskim jezikom. Vrlo je sličan drugim popularnim jezicima kao što su C#, JavaScript i ostali. Tako da ako se odlučite i za neki drugi jezik kasnije, neće vam biti teško da ga savladate.","title":"Početna stranica","url":"/index-3.html"},{"text":"Scala Scala je programski jezik visokog nivoa. Ime je dobila iz opisnog izraza \"SCAlable LAnguage\". Ubrzo ćemo vidjeti i zašto! :D Objedinjuje koncepte iz objektno orijentisanog programiranja (OOP) i funkcionalnog programiranja (FP). Pošto na raspolaganju imamo cijelu lepezu mogućnosti, treba znati pametno odabrati pravi skup \"alata\" za dati problem koji rješavamo. Primarna platforma na kojoj se izvršava je Java Virtuelna Mašina (JVM), pa se mogu koristiti svi library iz Jave. Scala ima statičke tipove, kao npr. C# ili Java, ali ima podršku čak i za dinamičke (Javascript, Ruby) i strukturalne tipove (kao Typescript)! Ovako je npr. podržana interoperabilnost sa Javascriptom, pogledajte ScalaJS projekat. Ima vrlo fleksibilnu i lijepu sintaksu, pa je pogodna i za pisanje DSL-ova (Domain-Specific Language). Postoje brojni library i frameworci za konkurentno i distribuirano programiranje. Neki od tih su Future (u standardnoj library), Akka Actors, Apache Spark, Kafka i dr. Lista tutorijala: Osnove","title":"Scala","url":"/scala/index.html"},{"text":"Java Pretpostavljam da ste prešli vizuelno programiranje. Ako niste, preporučujem da prvo pređete taj dio! Dosta vremena ćemo posvetiti objašnjavanju koncepata i terminologije. Terminologija je vrlo bitna, jer ćete kasnije lakše razgovarati o datim konceptima i brže ćete učiti ostale programske jezike, \"povezivati kockice\". Tutorijali: Instalacija Osnove Tipovi Naredbe Hello World! Uslovno grananje While petlja For petlja Funkcije Nizovi Tipovi, opet Klase Opseg","title":"Java","url":"/java/index.html"},{"text":"Java Pretpostavljam da ste prešli vizuelno programiranje. Ako niste, preporučujem da prvo pređete taj dio! Dosta vremena ćemo posvetiti objašnjavanju koncepata i terminologije. Terminologija je vrlo bitna, jer ćete kasnije lakše razgovarati o datim konceptima i brže ćete učiti ostale programske jezike, \"povezivati kockice\". Tutorijali: Instalacija Osnove Tipovi Naredbe Hello World! Uslovno grananje While petlja For petlja Funkcije Nizovi Tipovi, opet Klase Opseg","title":"Java","url":"/java/index-2.html"}]