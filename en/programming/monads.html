<!doctype html>
<html lang="en">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  <meta name="description" content="Monads introduction. Do notation, for comprehensions. Comparing monads with async and await syntax. Future, Observable, IO monad, Reactive programming.">
  <title> You already know Monad(ic) stuff | blog.sake.ba </title>
  <link rel="shortcut icon" href="/images/favicon.png" type="image/png">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/a11y-dark.min.css" media="(prefers-color-scheme: dark)" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/a11y-light.min.css" media="(prefers-color-scheme: light), (prefers-color-scheme: no-preference)" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.conditional.min.css">
  <link rel="stylesheet" href="/styles/default.css">
 </head>
 <body>
  <header class="pico container">
   <nav>
    <ul>
     <li><a href="/en">Home</a></li>
    </ul>
    <ul>
     <li>
      <form action="/search/results.html" method="GET">
       <input name="q" type="search" placeholder="Search">
      </form>
     </li>
    </ul>
    <ul>
     <li><a href="/en/flowrun">FlowRun</a></li>
     <li><a href="/en/java">Java</a></li>
     <li><a href="/en/scala">Scala</a></li>
     <li><a href="/en/programming">Programming</a></li>
     <li><a href="/en/maths">Maths</a></li>
     <li>
      <details class="dropdown">
       <summary> English </summary>
       <ul dir="rtl">
        <li><a href="/">Bosanski</a></li>
       </ul>
      </details>
     </li>
    </ul>
   </nav>
  </header>
  <main class="pico container">
   <div class="grid">
    <div>
     <details>
      <summary>Table of Contents</summary>
      <div>
       <ul>
        <li><a href="#monads">Monads</a>
         <ul>
          <li><a href="#haskell">Haskell</a>
           <ul>
            <li><a href="#laziness">Laziness</a></li>
            <li><a href="#pure-functions">Pure functions</a></li>
            <li><a href="#impure-functions">Impure functions</a></li>
            <li><a href="#main-function">Main function</a></li>
           </ul></li>
          <li><a href="#history-and-pre-history">History and pre-history</a></li>
          <li><a href="#monads-explained">Monads Explained</a>
           <ul>
            <li><a href="#syntax-sugar-for-monads">Syntax sugar for Monads</a></li>
           </ul></li>
          <li><a href="#async--await">Async / Await</a></li>
          <li><a href="#my-opinions">My opinions</a></li>
          <li><a href="#additional-resources">Additional resources</a></li>
         </ul></li>
       </ul>
      </div>
     </details>
     <hr>
    </div>
    <div></div>
    <div></div>
   </div>
   <h1 id="monads">Monads<a href="#monads" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h1>
   <p>I know... yet another Monad tutorial. ðŸ™ƒ</p>
   <p>Have you ever thought "hmm, these all look <em>kinda same</em>":</p>
   <ul>
    <li>Promise, Future, Rx, IO, Monad</li>
    <li><code>await</code>, <code>flatMap</code>, <code>do</code>, <code>for</code></li>
   </ul>
   <p>then you might be right!
    <br>
    Let's see!</p>
   <p>First we'll see how and why the <code>Monad</code> abstraction came into Haskell (a <em>purely functional</em> programming language).
    <br>
    Then we will see a nicer syntax for writing functions that operate on monads.
    <br>
    And lastly I will show you that <code>await</code>/<code>for</code>/<code>do</code> is "just nicer syntax" for <code>flatMap</code>.</p>
   <h2 id="haskell">Haskell<a href="#haskell" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h2>
   <p>A few relevant things about Haskell:</p>
   <ul>
    <li>it is a <strong>lazy</strong> language</li>
    <li>it wants to separate <strong>pure functions</strong> from <strong>impure functions (actions)</strong></li>
   </ul>
   <h3 id="laziness">Laziness<a href="#laziness" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h3>
   <p>By "lazy" we mean evaluation is not strict.
    <br>
    In Java for example, when you call a function <code>myFun(a, b)</code>, the <em>order of evaluation is strict</em> and <em>consistent</em>:</p>
   <ul>
    <li>first, the arguments are evaluated: left to right, one by one</li>
    <li>function is evaluated</li>
   </ul>
   <p>But in Haskell that's not the case. <em>Nothing is evaluated until needed</em>.
    <br>
    So if the parameter <code>a</code> is not used in the body of <code>myFun</code> <strong>it will not be evaluated at all</strong>.
    <br>
    This is fine+desirable+performant when your functions are pure (not <em>doing</em> anything),
    <br>
    but it is a big issue when they do <strong>side effects</strong>: write to a file/db etc.
    <br>
    For example, if you want these actions to be executed:</p>
   <ul>
    <li><code>f1</code> - write to a file</li>
    <li><code>f2</code> - read from that file</li>
   </ul>
   <p>you need to make sure that <code>f1</code> <strong>always gets evaluated before</strong> <code>f2</code> !!!
    <br>
    In Haskell you are <strong>never sure</strong> ðŸ˜± because <strong>eval order is unspecified</strong>...</p>
   <blockquote>
    <p>The next Haskell will be strict.
     <br>
     ~ Simon Peyton Jones</p>
   </blockquote>
   <h3 id="pure-functions">Pure functions<a href="#pure-functions" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h3>
   <p>Pure functions are like <strong>mathematical functions</strong>, they do calculations, and only return new values (no mutable variables).
    <br>
    They are only considering "insides" of a program, its own memory.</p>
   <h3 id="impure-functions">Impure functions<a href="#impure-functions" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h3>
   <p>Impure functions go <em>beyond our program</em>, they "go outside", play and get dirty.
    <br>
    They read/write to a file/console/database etc.</p>
   <p>Haskell wants you <em>not to get dirty</em>, and play as much as you can <em>inside</em> (stay safe).
    <br>
    But how does it know which functions are "impure"?
    <br>
    Well, by marking them with <code>IO</code> wrapper type (which is "a monad").</p>
   <h3 id="main-function">Main function<a href="#main-function" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h3>
   <p>"Normal" programming languages have a <code>main</code> function, which usually looks something like this:</p>
   <pre><code class="language-java hljs" data-highlighted="yes"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
}
</code></pre>
   <p>but in Haskell you have this:</p>
   <pre><code class="language-haskell hljs" data-highlighted="yes"><span class="hljs-title">main</span> :: <span class="hljs-type">IO</span> ()
<span class="hljs-title">main</span> = ...
</code></pre>
   <p>Haskell marks the <code>main</code> as an IO action, so by definition it is impure.</p>
   <h2 id="history-and-pre-history">History and pre-history<a href="#history-and-pre-history" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h2>
   <p>Before monads were introduced, main function's type looked like this:
    <br>
    <code>main :: [Response] -&gt; [Request]</code>.
    <br>
    Example taken from <a href="https://stackoverflow.com/a/17004448/4496364">StackOverflow</a>:</p>
   <pre><code class="language-haskell hljs" data-highlighted="yes"><span class="hljs-title">main</span> :: [<span class="hljs-type">Response</span>] -&gt; [<span class="hljs-type">Request</span>]
<span class="hljs-title">main</span> responses =
    [
    <span class="hljs-type">AppendChan</span> <span class="hljs-string">"stdout"</span> <span class="hljs-string">"Please enter a Number"</span>,
    <span class="hljs-type">ReadChan</span> <span class="hljs-string">"stdin"</span>,
    <span class="hljs-type">AppendChan</span> <span class="hljs-string">"stdout"</span> . show $ enteredNumber * <span class="hljs-number">2</span>
    ]
    <span class="hljs-keyword">where</span> (<span class="hljs-type">Str</span> input) = responses !! <span class="hljs-number">1</span>
        firstLine = head . lines $ input
        enteredNumber = read firstLine 
</code></pre>
   <p>In a nutshell, you had to <strong>write all of the impure stuff</strong> that your whole program will do <strong>as a return value</strong>.
    <br>
    That is represented as a <em>list of requests</em>: <code>[Request]</code>.
    <br>
    Return values from those IO actions are delivered in the <code>[Response]</code> list, that you use inside the program logic.</p>
   <p>The <em>number of responses</em> is the same as the <em>number of requests</em> you gave.
    <br>
    So you have to keep in mind the indices, which is a bummer. What if you add one request in the middle? You'd have to change all indices after it...
    <br>
    Which request belongs to which response? That's really hard to see.
    <br>
    We can already see that this way of writing a program is very <strong>cumbersome, unreadable, and limited</strong>.</p>
   <p>Notice also that the approach above works only because Haskell is lazy!</p>
   <h2 id="monads-explained">Monads Explained<a href="#monads-explained" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h2>
   <p>Back to <code>IO t</code>. The <code>IO t</code> is an action that will do some <em>side effects</em> before returning a value of type <code>t</code>.
    <br>
    This can be <em>anything</em>: writing to disk, sending HTTP requests etc.
    <br>
    Examples of impure functions in Haskell:</p>
   <pre><code class="language-haskell hljs" data-highlighted="yes"><span class="hljs-title">getChar</span> :: <span class="hljs-type">IO</span> <span class="hljs-type">Char</span>
<span class="hljs-title">putChar</span> :: <span class="hljs-type">Char</span> -&gt; <span class="hljs-type">IO</span> ()
</code></pre>
   <p>You are probably familiar with some <em>functions</em> that operate <em>on the value inside</em> the <code>IO</code>!
    <br>
    For example, we have <code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code> which transforms the value inside any Functor <code>f</code> (monad is a functor).</p>
   <p>But what about chaining, sequencing actions one after another?
    <br>
    How can we ensure that <code>getChar</code> executes <em>strictly before</em> <code>putChar</code>?
    <br>
    Monads to the rescue! Its core function is called <code>flatMap</code> (or <code>bind</code>, or <code>&gt;&gt;=</code> ..):</p>
   <pre><code class="language-haskell hljs" data-highlighted="yes">(&gt;&gt;=) :: <span class="hljs-type">IO</span> a -&gt; (a -&gt; <span class="hljs-type">IO</span> b) -&gt; <span class="hljs-type">IO</span> b
</code></pre>
   <p>The <code>flatMap</code> function:</p>
   <ul>
    <li>takes an <code>IO a</code> action</li>
    <li>takes a function that takes <code>a</code> (the <code>a</code> from <code>IO a</code>)</li>
    <li>returns a new <code>IO b</code></li>
   </ul>
   <p>So there we have it, Monad in all its glory! :)
    <br>
    It's "just" a semicolon (<code>;</code>), duhh, sequencing operations.</p>
   <p>Let's see our solution now:</p>
   <pre><code class="language-haskell hljs" data-highlighted="yes"><span class="hljs-title">echo</span> = getChar &gt;&gt;= putChar

<span class="hljs-comment">-- or more verbosely</span>
<span class="hljs-title">echo</span> = getChar &gt;&gt;= (\\c -&gt; putChar c)

<span class="hljs-comment">-- or verbosiest</span>
<span class="hljs-title">echo</span> = (&gt;&gt;=) getChar (\\c -&gt; putChar c)
</code></pre>
   <p>In Scala you'd write <code>val echo = getChar.flatMap(putChar)</code>.</p>
   <p>This is the <strong>reason why Monads were introduced in Haskell</strong>.</p>
   <blockquote>
    <p>In short, Haskell is the world's finest imperative programming language.
     <br>
     ~ Simon Peyton Jones</p>
   </blockquote>
   <h3 id="syntax-sugar-for-monads">Syntax sugar for Monads<a href="#syntax-sugar-for-monads" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h3>
   <p>Haskell and some other languages have built-in syntax for Monads.
    <br>
    Haskell has "do notation" and Scala has "for comprehensions".
    <br>
    It makes them more readable by flipping sides:</p>
   <pre><code class="language-haskell hljs" data-highlighted="yes"><span class="hljs-title">echo</span> = <span class="hljs-keyword">do</span>
    c &lt;- getChar
    putChar c
</code></pre>
   <p>Scala:</p>
   <pre><code class="language-scala hljs" data-highlighted="yes"><span class="hljs-keyword">val</span> echo = <span class="hljs-keyword">for</span> {
    c &lt;- getChar
    _ &lt;- putChar(c)
} <span class="hljs-keyword">yield</span> ()
</code></pre>
   <p>The <code>&lt;-</code> symbol gets translated into <code>&gt;&gt;=</code> by Haskell's compiler.
    <br>
    In case of Scala, it gets turned into a <code>flatMap</code>.</p>
   <hr>
   <p>It turns out that Monads are useful not only in the <code>IO</code> context, but for other types too.
    <br>
    Whenever you have unwanted nesting like <code>Wrapper[Wrapper[T]]</code>, you need to "flatMap that shit", hence you need a Monad.
    <br>
    If you have <code>List[List[String]]</code> you probably needed a <code>flatMap</code> instead of <code>map</code>.
    <br>
    If you have <code>Option[Option[String]]</code>, same thing.</p>
   <p>You can imagine doing the same example above with a <code>List[T]</code>, where <code>c</code> would be <em>one element of the list</em>.</p>
   <h2 id="async--await">Async / Await<a href="#async--await" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h2>
   <p>After some time it came to my mind that we are doing a similar thing in JS/C#/Kotlin with <code>await</code>. It is almost the same thing, we are "pulling a value from a Promise/Task" (~Monads):</p>
   <pre><code class="language-js hljs language-javascript" data-highlighted="yes"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUserMovies</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/user'</span>);
    <span class="hljs-keyword">const</span> movies = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/user/<span class="hljs-subst">${user.id}</span>/movies`</span>);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(movies);
    <span class="hljs-keyword">return</span> movies;
}
</code></pre>
   <p>Before this we used to write "normal callback functions":</p>
   <pre><code class="language-js hljs language-javascript" data-highlighted="yes"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchUserMovies</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">'/user'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> {
        <span class="hljs-title function_">fetch</span>(<span class="hljs-string">`/user/<span class="hljs-subst">${user.id}</span>/movies`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">movies</span> =&gt;</span> {
            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(movies);
            <span class="hljs-keyword">return</span> movies;
        });
    });
}
</code></pre>
   <p>Seems like <code>then</code> corresponds to <code>flatMap</code>, and <code>await</code> corresponds to <code>&lt;-</code> syntax sugar.
    <br>
    Some noticable differences:</p>
   <ul>
    <li>do/for is general, while await is specific just for Promise</li>
    <li>do/for in statically typed languages is checked for proper types, while in JS you're on your own</li>
   </ul>
   <h2 id="my-opinions">My opinions<a href="#my-opinions" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h2>
   <p>To me, it feels very awkward to program in a lazy programming language.
    <br>
    It is hard to reason about and you <em>have to use monads</em> for doing even the simplest IO operations.
    <br>
    If you have a pure function and want to <code>println</code> a value.. nope, you gotta wrap everything in an <code>IO</code>.. wack.</p>
   <p>When used inside a normally strict language like Scala or Java, it "spreads like a virus".
    <br>
    If you have an <code>IO[String]</code>, all code that calls it <strong>must be an IO[..]</strong>!! It's viral! No bueno!
    <br>
    You have to ask yourself: is all that complexity <em>really worth it</em>? IMHO it is not, 99% of the time.
    <br>
    Especially today when we have JVM virtual threads.</p>
   <p>So, in my opinion, use Monads/Rx/whatever <strong>only when you have to</strong>!
    <br>
    The simpler the program - the better.</p>
   <p>For example, in Java you can use threads and concurrent datastructures. Web servers like Tomcat, Jetty etc. are working just fine with a thread-per-request model.</p>
   <p>But in JS you don't have that liberty, you <strong>need to use Promises</strong>.
    <br>
    That's because JS doesn't have "normal threads", is has only one thread with an event-loop so you have to program asynchronous code.</p>
   <hr>
   <p>I hope this gave you a better insight into scary Monads and the FP way of handling IO.</p>
   <h2 id="additional-resources">Additional resources<a href="#additional-resources" class="flatmark-anchor" aria-label="Anchor"> ðŸ”—</a></h2>
   <ul>
    <li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf?from=https%3A%2F%2Fresearch.microsoft.com%2F%7Esimonpj%2Fpapers%2Fmarktoberdorf%2Fmark.pdf">Tackling the Awkward Squad</a> by Simon Peyton Jones</li>
    <li><a href="https://www.youtube.com/watch?v=9TR--8gAcZ8">Essential Effects</a> by Adam Rosien</li>
    <li><a href="https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part1.html">State of Loom</a> by Ron Pressler (comparing RX vs threads)</li>
    <li><a href="https://gist.github.com/dcastro/c451883ff8aac44c57233ef1c6fd75ee">Future vs IO</a> by Diogo Castro</li>
    <li><a href="https://medium.com/@luijar/the-observable-disguised-as-an-io-monad-c89042aa8f31">The Observable disguised as an IO Monad</a> by Luis Atencio</li>
    <li><a href="https://www.reddit.com/r/scala/comments/8ygjcq/can_someone_explain_to_me_the_benefits_of_io/">Benefits of IO discussion on Reddit</a></li>
   </ul>
  </main>
  <footer class="pico container">blog.sake.ba</footer>
 </body>
</html>