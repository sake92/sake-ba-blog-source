<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="ie=edge" /><meta name="viewport" content="width=device-width, initial-scale=1" /><meta name="generator" content="hepek" /><meta name="theme-color" content="#000" /><meta name="mobile-web-app-capable" content="yes" /><meta name="description" content="Monads introduction. Do notation, for comprehensions. Comparing monads with async and await syntax. Future, Observable, IO monad, Reactive programming." /><meta property="og:title" content="blog.sake.ba" /><meta name="twitter:card" content="summary_large_image" /><title>You already know Monad(ic) stuff - blog.sake.ba</title><link rel="shortcut icon" href="../../../images/favicon.svg" type="image/svg+xml" /><link rel="stylesheet" href="../../../styles/vendor/pico.conditional.min.css" /><link rel="stylesheet" href="../../../styles/main.css" /><link rel="manifest" href="../../../manifest.json" /></head><body class="match-braces"><main class="pico container"><nav><ul><li><a href="../../index.html"><span><img src="/images/logo.png" alt="logo" style="height: 32px;" /></span><strong>blog.sake.ba</strong></a></li></ul><ul><li><a href="index.html" class="">Programming</a></li></ul></nav><div class="blog-post"><aside><nav><ul><li><a href="monads.html" class="">Monadic stuff</a></li><li><a href="api-first-scala.html" class="secondary">API-First Scala</a></li></ul></nav></aside><article><section><h2 id="intro">Intro</h2><p>I know.. yet another Monad tutorial. :)</p>
<p>Have you ever thought &quot;hmm, these all look <em>kinda same</em>&quot;:</p>
<ul>
<li>Promise, Future, Rx, IO, Monad</li>
<li><code>await</code>, <code>flatMap</code>, <code>do</code>, <code>for</code></li>
</ul>
<p>then you might be right!<br />
Let's see!</p>
<p>First we'll see how and why the <code>Monad</code> abstraction came into Haskell (a <em>purely functional</em> programming language).<br />
Then we will see a nicer syntax for writing functions that operate on monads.<br />
And lastly I will show you that <code>await</code>/<code>for</code>/<code>do</code> is &quot;just nicer syntax&quot; for <code>flatMap</code>.</p>
</section><section><h2 id="haskell">Haskell</h2><p>A few relevant things about Haskell:</p>
<ul>
<li>it is a <strong>lazy</strong> language</li>
<li>it wants to separate <strong>pure functions</strong> from <strong>impure functions (actions)</strong></li>
</ul>
<h3>Laziness</h3>
<p>By &quot;lazy&quot; we mean evaluation is not strict.<br />
In Java for example, when you call a function <code>myFun(a, b)</code>, the <em>order of evaluation is strict</em> and <em>consistent</em>:</p>
<ul>
<li>first, the arguments are evaluated: left to right, one by one</li>
<li>function is evaluated</li>
</ul>
<p>But in Haskell that's not the case. <em>Nothing is evaluated until needed</em>.<br />
So if the parameter <code>a</code> is not used in the body of <code>myFun</code> <strong>it will not be evaluated at all</strong>.<br />
This is fine+desirable+performant when your functions are pure (not <em>doing</em> anything),<br />
but it is a big issue when they do <strong>side effects</strong>: write to a file/db etc.<br />
For example, if you want these actions to be executed:</p>
<ul>
<li><code>f1</code> - write to a file</li>
<li><code>f2</code> - read from that file</li>
</ul>
<p>you need to make sure that <code>f1</code> <strong>always gets evaluated before</strong> <code>f2</code>!!<br />
In Haskell you are never sure because eval order is unspecified..</p>
<blockquote>
<p>The next Haskell will be strict.<br />
~ Simon Peyton Jones</p>
</blockquote>
<h3>Pure functions</h3>
<p>Pure functions are like <strong>mathematical functions</strong>, they do calculations, and only return new values (no mutable variables).<br />
They are only considering &quot;insides&quot; of a program, its own memory.</p>
<h3>Impure functions</h3>
<p>Impure functions go <em>beyond our program</em>, they &quot;go outside&quot;, play and get dirty.<br />
They read/write to a file/console/database etc.</p>
<p>Haskell wants you <em>not to get dirty</em>, and play as much as you can <em>inside</em> (stay safe).<br />
But how does it know which functions are &quot;impure&quot;?<br />
Well, by marking them with <code>IO</code> wrapper type (which is &quot;a monad&quot;).</p>
<h3>Main function</h3>
<p>&quot;Normal&quot; programming languages have a <code>main</code> function, which usually looks something like this:</p>
<pre class="shiki material-theme-ocean" style="background-color:#0F111A;color:#babed8" tabindex="0"><code><span class="line"><span style="color:#C792EA">static</span><span style="color:#C792EA"> void</span><span style="color:#82AAFF"> main</span><span style="color:#89DDFF">(</span><span style="color:#C792EA">String</span><span style="color:#89DDFF">[]</span><span style="color:#BABED8"> args</span><span style="color:#89DDFF">)</span><span style="color:#89DDFF"> {</span></span>
<span class="line"><span style="color:#89DDFF">}</span></span></code></pre>
<p>but in Haskell you have this:</p>
<pre class="shiki material-theme-ocean" style="background-color:#0F111A;color:#babed8" tabindex="0"><code><span class="line"><span style="color:#82AAFF">main</span><span style="color:#89DDFF"> ::</span><span style="color:#C792EA"> IO</span><span style="color:#89DDFF"> ()</span></span>
<span class="line"><span style="color:#BABED8">main </span><span style="color:#89DDFF">=</span><span style="color:#89DDFF"> ...</span></span></code></pre>
<p>Haskell marks the <code>main</code> as an IO action, so by definition it is impure.</p>
</section><section><h2 id="history-and-pre-history">History and pre-history</h2><p>Before monads were introduced, main function's type looked like this:<br />
<code>main :: [Response] -&gt; [Request]</code>.<br />
Example taken from <a href="https://stackoverflow.com/a/17004448/4496364">StackOverflow</a>:</p>
<pre class="shiki material-theme-ocean" style="background-color:#0F111A;color:#babed8" tabindex="0"><code><span class="line"><span style="color:#82AAFF">main</span><span style="color:#89DDFF"> ::</span><span style="color:#89DDFF"> [</span><span style="color:#C792EA">Response</span><span style="color:#89DDFF">]</span><span style="color:#89DDFF"> -></span><span style="color:#89DDFF"> [</span><span style="color:#C792EA">Request</span><span style="color:#89DDFF">]</span></span>
<span class="line"><span style="color:#BABED8">main responses </span><span style="color:#89DDFF">=</span></span>
<span class="line"><span style="color:#89DDFF">  [</span></span>
<span class="line"><span style="color:#BABED8">    AppendChan </span><span style="color:#89DDFF">"</span><span style="color:#C3E88D">stdout</span><span style="color:#89DDFF">"</span><span style="color:#89DDFF"> "</span><span style="color:#C3E88D">Please enter a Number</span><span style="color:#89DDFF">"</span><span style="color:#89DDFF">,</span></span>
<span class="line"><span style="color:#BABED8">    ReadChan </span><span style="color:#89DDFF">"</span><span style="color:#C3E88D">stdin</span><span style="color:#89DDFF">"</span><span style="color:#89DDFF">,</span></span>
<span class="line"><span style="color:#BABED8">    AppendChan </span><span style="color:#89DDFF">"</span><span style="color:#C3E88D">stdout</span><span style="color:#89DDFF">"</span><span style="color:#89DDFF"> .</span><span style="color:#BABED8"> show </span><span style="color:#89DDFF">$</span><span style="color:#BABED8"> enteredNumber </span><span style="color:#89DDFF">*</span><span style="color:#F78C6C"> 2</span></span>
<span class="line"><span style="color:#89DDFF">  ]</span></span>
<span class="line"><span style="color:#F78C6C">  where</span><span style="color:#89DDFF"> (</span><span style="color:#BABED8">Str input</span><span style="color:#89DDFF">)</span><span style="color:#89DDFF"> =</span><span style="color:#BABED8"> responses </span><span style="color:#89DDFF">!!</span><span style="color:#F78C6C"> 1</span></span>
<span class="line"><span style="color:#BABED8">        firstLine </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> head </span><span style="color:#89DDFF">.</span><span style="color:#BABED8"> lines </span><span style="color:#89DDFF">$</span><span style="color:#BABED8"> input</span></span>
<span class="line"><span style="color:#BABED8">        enteredNumber </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> read firstLine</span></span></code></pre>
<p>In a nutshell, you had to <strong>write all of the impure stuff</strong> that your whole program will do <strong>as a return value</strong>.<br />
That is represented as a <em>list of requests</em>: <code>[Request]</code>.<br />
Return values from those IO actions are delivered in the <code>[Response]</code> list, that you use inside the program logic.</p>
<p>The <em>number of responses</em> is the same as the <em>number of requests</em> you gave.<br />
So you have to keep in mind the indices, which is a bummer.
What if you add one request in the middle? You'd have to change all indices after it...<br />
Which request belongs to which response? That's really hard to see.<br />
We can already see that this way of writing a program is very <strong>cumbersome, unreadable, and limited</strong>.</p>
<p>Notice also that the approach above works only because Haskell is lazy!</p>
</section><section><h2 id="monads">Monads</h2><p>Back to <code>IO t</code>. The <code>IO t</code> is an action that will do some <em>side effects</em> before returning a value of type <code>t</code>.<br />
This can be <em>anything</em>: writing to disk, sending HTTP requests etc.<br />
Examples of impure functions in Haskell:</p>
<pre class="shiki material-theme-ocean" style="background-color:#0F111A;color:#babed8" tabindex="0"><code><span class="line"><span style="color:#82AAFF">getChar</span><span style="color:#89DDFF"> ::</span><span style="color:#C792EA"> IO</span><span style="color:#C792EA"> Char</span></span>
<span class="line"><span style="color:#82AAFF">putChar</span><span style="color:#89DDFF"> ::</span><span style="color:#C792EA"> Char</span><span style="color:#89DDFF"> -></span><span style="color:#C792EA"> IO</span><span style="color:#89DDFF"> ()</span></span></code></pre>
<p>You are probably familiar with some <em>functions</em> that operate <em>on the value inside</em> the <code>IO</code>!<br />
For example, we have <code>fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code> which transforms the value inside any Functor <code>f</code> (monad is a functor).</p>
<p>But what about chaining, sequencing actions one after another?<br />
How can we ensure that <code>getChar</code> executes <em>strictly before</em> <code>putChar</code>?<br />
Monads to the rescue! Its core function is called <code>flatMap</code> (or <code>bind</code>, or <code>&gt;&gt;=</code> ..):</p>
<pre class="shiki material-theme-ocean" style="background-color:#0F111A;color:#babed8" tabindex="0"><code><span class="line"><span style="color:#89DDFF">(</span><span style="color:#82AAFF">>>=</span><span style="color:#89DDFF">)</span><span style="color:#89DDFF"> ::</span><span style="color:#C792EA"> IO</span><span style="color:#BABED8"> a </span><span style="color:#89DDFF">-></span><span style="color:#89DDFF"> (</span><span style="color:#BABED8">a </span><span style="color:#89DDFF">-></span><span style="color:#C792EA"> IO</span><span style="color:#BABED8"> b</span><span style="color:#89DDFF">)</span><span style="color:#89DDFF"> -></span><span style="color:#C792EA"> IO</span><span style="color:#BABED8"> b</span></span></code></pre>
<p>The <code>flatMap</code> function:</p>
<ul>
<li>takes an <code>IO a</code> action</li>
<li>takes a function that takes <code>a</code> (the <code>a</code> from <code>IO a</code>)</li>
<li>returns a new <code>IO b</code></li>
</ul>
<p>So there we have it, Monad in all its glory! :)<br />
It's &quot;just&quot; a semicolon (<code>;</code>), duhh, sequencing operations.</p>
<p>Let's see our solution now:</p>
<pre class="shiki material-theme-ocean" style="background-color:#0F111A;color:#babed8" tabindex="0"><code><span class="line"><span style="color:#BABED8">echo </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> getChar </span><span style="color:#89DDFF">>>=</span><span style="color:#BABED8"> putChar</span></span>
<span class="line"></span>
<span class="line"><span style="color:#464B5D;font-style:italic">-- or more verbosely</span></span>
<span class="line"><span style="color:#BABED8">echo </span><span style="color:#89DDFF">=</span><span style="color:#BABED8"> getChar </span><span style="color:#89DDFF">>>=</span><span style="color:#89DDFF"> (\</span><span style="color:#BABED8">c </span><span style="color:#89DDFF">-></span><span style="color:#BABED8"> putChar c</span><span style="color:#89DDFF">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#464B5D;font-style:italic">-- or verbosiest</span></span>
<span class="line"><span style="color:#BABED8">echo </span><span style="color:#89DDFF">=</span><span style="color:#89DDFF"> (</span><span style="color:#82AAFF">>>=</span><span style="color:#89DDFF">)</span><span style="color:#BABED8"> getChar </span><span style="color:#89DDFF">(\</span><span style="color:#BABED8">c </span><span style="color:#89DDFF">-></span><span style="color:#BABED8"> putChar c</span><span style="color:#89DDFF">)</span></span></code></pre>
<p>In Scala you'd write <code>val echo = getChar.flatMap(putChar)</code>.</p>
<p>This is the <strong>reason why Monads were introduced in Haskell</strong>.</p>
<blockquote>
<p>In short, Haskell is the world's finest imperative programming language.<br />
~ Simon Peyton Jones</p>
</blockquote>
<h3>Syntax sugar for Monads</h3>
<p>Haskell and some other languages have built-in syntax for Monads.<br />
Haskell has &quot;do notation&quot; and Scala has &quot;for comprehensions&quot;.<br />
It makes them more readable by flipping sides:</p>
<pre class="shiki material-theme-ocean" style="background-color:#0F111A;color:#babed8" tabindex="0"><code><span class="line"><span style="color:#BABED8">echo </span><span style="color:#89DDFF">=</span><span style="color:#89DDFF;font-style:italic"> do</span></span>
<span class="line"><span style="color:#BABED8">    c </span><span style="color:#89DDFF">&#x3C;-</span><span style="color:#BABED8"> getChar</span></span>
<span class="line"><span style="color:#BABED8">    putChar c</span></span></code></pre>
<p>Scala:</p>
<pre class="shiki material-theme-ocean" style="background-color:#0F111A;color:#babed8" tabindex="0"><code><span class="line"><span style="color:#89DDFF">val</span><span style="color:#BABED8"> echo </span><span style="color:#89DDFF">=</span><span style="color:#89DDFF;font-style:italic"> for</span><span style="color:#89DDFF"> {</span></span>
<span class="line"><span style="color:#BABED8">    c </span><span style="color:#89DDFF">&#x3C;-</span><span style="color:#BABED8"> getChar</span></span>
<span class="line"><span style="color:#BABED8">    _ </span><span style="color:#89DDFF">&#x3C;-</span><span style="color:#BABED8"> putChar(c)</span></span>
<span class="line"><span style="color:#89DDFF">}</span><span style="color:#89DDFF;font-style:italic"> yield</span><span style="color:#BABED8"> ()</span></span></code></pre>
<p>The <code>&lt;-</code> symbol gets translated into <code>&gt;&gt;=</code> by Haskell's compiler.<br />
In case of Scala, it gets turned into a <code>flatMap</code>.</p>
<hr />
<p>It turns out that Monads are useful not only in the <code>IO</code> context, but for other types too.<br />
Whenever you have unwanted nesting like <code>Wrapper[Wrapper[T]]</code>, you need to &quot;flatMap that shit&quot;, hence you need a Monad.<br />
If you have <code>List[List[String]]</code> you probably needed a <code>flatMap</code> instead of <code>map</code>.<br />
If you have <code>Option[Option[String]]</code>, same thing.</p>
<p>You can imagine doing the same example above with a <code>List[T]</code>, where <code>c</code> would be <em>one element of the list</em>.</p>
</section><section><h2 id="async-await">Async / Await</h2><p>After some time it came to my mind that we are doing a similar thing in JS/C#/Kotlin with <code>await</code>.
It is almost the same thing, we are &quot;pulling a value from a Promise/Task&quot; (~Monads):</p>
<pre class="shiki material-theme-ocean" style="background-color:#0F111A;color:#babed8" tabindex="0"><code><span class="line"><span style="color:#C792EA">async</span><span style="color:#C792EA"> function</span><span style="color:#82AAFF"> fetchUserMovies</span><span style="color:#89DDFF">()</span><span style="color:#89DDFF"> {</span></span>
<span class="line"><span style="color:#C792EA">  const</span><span style="color:#BABED8"> user</span><span style="color:#89DDFF"> =</span><span style="color:#89DDFF;font-style:italic"> await</span><span style="color:#82AAFF"> fetch</span><span style="color:#F07178">(</span><span style="color:#89DDFF">'</span><span style="color:#C3E88D">/user</span><span style="color:#89DDFF">'</span><span style="color:#F07178">)</span><span style="color:#89DDFF">;</span></span>
<span class="line"><span style="color:#C792EA">  const</span><span style="color:#BABED8"> movies</span><span style="color:#89DDFF"> =</span><span style="color:#89DDFF;font-style:italic"> await</span><span style="color:#82AAFF"> fetch</span><span style="color:#F07178">(\</span><span style="color:#89DDFF">`</span><span style="color:#C3E88D">/user/</span><span style="color:#BABED8">\$</span><span style="color:#C3E88D">{user.id}/movies</span><span style="color:#BABED8">\`</span><span style="color:#C3E88D">);</span></span>
<span class="line"><span style="color:#C3E88D">  console.log(movies);</span></span>
<span class="line"><span style="color:#C3E88D">  return movies;</span></span>
<span class="line"><span style="color:#C3E88D">}</span></span></code></pre>
<p>Before this we used to write &quot;normal callback functions&quot;:</p>
<pre class="shiki material-theme-ocean" style="background-color:#0F111A;color:#babed8" tabindex="0"><code><span class="line"><span style="color:#C792EA">function</span><span style="color:#82AAFF"> fetchUserMovies</span><span style="color:#89DDFF">()</span><span style="color:#89DDFF"> {</span></span>
<span class="line"><span style="color:#82AAFF">    fetch</span><span style="color:#F07178">(</span><span style="color:#89DDFF">'</span><span style="color:#C3E88D">/user</span><span style="color:#89DDFF">'</span><span style="color:#F07178">)</span><span style="color:#89DDFF">.</span><span style="color:#82AAFF">then</span><span style="color:#F07178">(</span><span style="color:#BABED8;font-style:italic">user</span><span style="color:#C792EA"> =></span><span style="color:#89DDFF"> {</span></span>
<span class="line"><span style="color:#82AAFF">        fetch</span><span style="color:#F07178">(\</span><span style="color:#89DDFF">`</span><span style="color:#C3E88D">/user/</span><span style="color:#BABED8">\$</span><span style="color:#C3E88D">{user.id}/movies</span><span style="color:#BABED8">\`</span><span style="color:#C3E88D">).then(movies => {</span></span>
<span class="line"><span style="color:#C3E88D">            console.log(movies);</span></span>
<span class="line"><span style="color:#C3E88D">            return movies;</span></span>
<span class="line"><span style="color:#C3E88D">        });</span></span>
<span class="line"><span style="color:#C3E88D">    });</span></span>
<span class="line"><span style="color:#C3E88D">}</span></span></code></pre>
<p>Seems like <code>then</code> corresponds to <code>flatMap</code>, and <code>await</code> corresponds to <code>&lt;-</code> syntax sugar.<br />
Some noticable differences:</p>
<ul>
<li>do/for is general, while await is specific just for Promise</li>
<li>do/for in statically typed languages is checked for proper types, while in JS you're on your own</li>
</ul>
</section><section><h2 id="my-opinions">My opinions</h2><p>To me, it feels very awkward to program in a lazy programming language.<br />
It is hard to reason about and you <em>have to use monads</em> for doing even the simplest IO operations.<br />
If you have a pure function and want to <code>println</code> a value.. nope, you gotta wrap everything in an <code>IO</code>.. wack.</p>
<p>When used inside a normally strict language like Scala or Java, it &quot;spreads like a virus&quot;.<br />
If you have an <code>IO[String]</code>, all code that calls it <strong>must be an IO[..]</strong>!! It's viral! No bueno!<br />
You have to ask yourself: is all that complexity <em>really worth it</em>? IMHO it is not, 99% of the time.<br />
Especially today when we have JVM virtual threads.</p>
<p>So, in my opinion, use Monads/Rx/whatever <strong>only when you have to</strong>!<br />
The simpler the program - the better.</p>
<p>For example, in Java you can use threads and concurrent datastructures.
Web servers like Tomcat, Jetty etc. are working just fine with a thread-per-request model.</p>
<p>But in JS you don't have that liberty, you <strong>need to use Promises</strong>.<br />
That's because JS doesn't have &quot;normal threads&quot;, is has only one thread with an event-loop so you have to program asynchronous code.</p>
<hr />
<p>I hope this gave you a better insight into scary Monads and the FP way of handling IO.</p>
</section><section><h2 id="additional-resources">Additional resources</h2><ul>
<li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf?from=https%3A%2F%2Fresearch.microsoft.com%2F%7Esimonpj%2Fpapers%2Fmarktoberdorf%2Fmark.pdf">Tackling the Awkward Squad</a> by Simon Peyton Jones</li>
<li><a href="https://www.youtube.com/watch?v=9TR--8gAcZ8">Essential Effects</a> by Adam Rosien</li>
<li><a href="https://cr.openjdk.java.net/~rpressler/loom/loom/sol1_part1.html">State of Loom</a> by Ron Pressler (comparing RX vs threads)</li>
<li><a href="https://gist.github.com/dcastro/c451883ff8aac44c57233ef1c6fd75ee">Future vs IO</a> by Diogo Castro</li>
<li><a href="https://medium.com/@luijar/the-observable-disguised-as-an-io-monad-c89042aa8f31">The Observable disguised as an IO Monad</a> by Luis Atencio</li>
<li><a href="https://www.reddit.com/r/scala/comments/8ygjcq/can_someone_explain_to_me_the_benefits_of_io/">Benefits of IO discussion on Reddit</a></li>
</ul>
</section></article></div></main><script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.1.0/anchor.min.js"></script><script src="../../../scripts/main.js"></script></body></html>